# 개요
최범균님의 DDD START 책을 읽고 정리합니다.
- [개요](#개요)
- [CH 1 도메인 모델 시작](#ch-1-도메인-모델-시작)
  - [도메인](#도메인)
  - [도메인 모델 패턴](#도메인-모델-패턴)
  - [도메인 모델 도출](#도메인-모델-도출)
  - [문서화](#문서화)
  - [코드도 문서화이다.](#코드도-문서화이다)
- [CH 2 아키텍처 개요](#ch-2-아키텍처-개요)
  - [DIP](#dip)
  - [DIP 주의점](#dip-주의점)
  - [도메인 영역의 주요 구성요소](#도메인-영역의-주요-구성요소)
  - [엔티티와 밸류](#엔티티와-밸류)
  - [밸류 타입 주의점](#밸류-타입-주의점)
- [CH 3 애그리거트](#ch-3-애그리거트)
  - [애그리거트 루트](#애그리거트-루트)
  - [트랜잭션 범위](#트랜잭션-범위)
  - [트랜잭션 범위와 애그리거트](#트랜잭션-범위와-애그리거트)
  - [ID를 이용한 애그리거트 참조](#id를-이용한-애그리거트-참조)
  - [ID를 이용한 참조와 조회 성능](#id를-이용한-참조와-조회-성능)

# CH 1 도메인 모델 시작
## 도메인

도메인의 사전적 정의는 다음과 같다.

**도메인** ([위키백과](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B3%B5%ED%95%99)))
> 일반적인 요구사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역이다. 도메인 엔지니어링이라고도 알려져 있다.

결국 도메인은 소프트웨어로 해결하고자 하는 문제 영역을 의미한다.

## 도메인 모델 패턴
아래 도메인 모델은 마틴 파울러가 쓴 `엔터프라이즈 애플리케이션 아키텍쳐 패턴(PEAA)` 책의 도메인 모델 패턴을 의미한다.

**도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말한다.**


| 계층(Layer)                                               | 설명                                                                                                       |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **사용자인터페이스**(UI) or <br> **표현** ( Presentation) | 사용자의 요청 처리 및 정보 제공                                                                            |
| 응용(Application)                                         | 사용자가 요청한 기능을 실행, **업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합해서 기능을 수행한다.** |
| 도메인                                                    | 시스템이 제공할 도메인의 규칙을 구현                                                                       |
| 인프라스트럭처(infrastructor)                             | 데이터베이스나 메시지 시스템과 같은 외부 시스템과의 연동을 처리 : 인프라(DB 등)를 기준으로!                |


## 도메인 모델 도출

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
그리고 이는 요구사항에서 출발한다.

- enum으로 구현된 status 안에 isChangeable 메서드를 넣기보단 해당 status를 멤버로 쓰는 root 클래스에 넣자. <br> -> root 클래스 내에서 여러 멤버를 통해 isChangeable을 판별해야할 수도 있다.


## 문서화
- 문서화를 하는 주된 이유는 지식 공유이다.
- 실제 구현은 코드에 있으므로 모든 것은 코드를 보면 알 수 있지만, 코드는 상세한 내용을 모두 다루고 있기에 소프트웨어를 전체적으로 분석하려면 많은 시간이 필요하다. 따라서 정리된 문서를 참조하는 것이 전반적인 소프트웨어를 이해하는데 도움이 된다!
- 그리고 이후에 더 깊게 이해할 필요가 있는 부분을 코드로 분석해 나가면 된다.

## 코드도 문서화이다.
- 코드를 보면서 도메인을 깊게 이해하게 되므로 코드도 문서화의 대상이다.
- 보기 좋은 코드를 작성하면서 도메인 관점에서도 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.
# CH 2 아키텍처 개요

보통 아키텍처를 설계할 때 다음과 같은 4개의 영역을 떠올릴 수 있다.
그리고 각 영역의 역할은 위 CH 1에서 본 내용과 같다.

- `표현`
- `응용`
- `도메인`
- `인프라스트럭처` 

## DIP 
DIP(의존관계 역전 원칙)를 이용하면 저수준 모듈에 의존하던 상태를 고수준 모듈에 의존하도록 변경해서 저수준 모듈이 변경되어도 유연하게 대처할 수 있다.

또한, 이는 인터페이스만 mocking하면 되기 때문에 테스트 코드를 작성하기에도 유리하다. 
## DIP 주의점
DIP는 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.
단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들이는 것은 위험하다.

## 도메인 영역의 주요 구성요소
| 요소                                  | 설명                                                                                                                                                                                                                                                 |
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **엔티티** <br> ENTITY                | 고유 식별자를 갖는 객체이며, 자신의 라이프사이클을 갖는다. 그리고 주문 등과 같이 도메인의 고유한 개념을 표현하고, 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.                                                         |
| **밸류** <br> VALUE                   | 고유의 식별자를 갖지 않는 객체. 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용됨(ex- OrderStatus, 주소(Address), )                                                                                                                       |
| **애그리거트** <br> AGGREGATE         | 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있음.                                                                                   |
| **리포지터리** <br> REPOSITORY        | 도메인 모델의 영속성을 처리. ex) JpaRepository, MabatisRepository                                                                                                                                                                                    |
| **도메인 서비스** <br> DOMAIN SERVICE | 특정 엔티티에 속하지 않은 도메인 로직을 제공. 예를 들어 `할인 금액 계산`은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 될텐데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하는 경우 도메인 서비스에서 로직을 구현한다. |

## 엔티티와 밸류
- 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보단 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화하여 데이터가 임의로 변경되는 것을 막는다.
- 이런 기능을 제공한다는 점에서 DB 테이블의 엔티티와 도메인 모델의 엔티티는 다르다는 것을 알 수 있다.

## 밸류 타입 주의점

  항상 밸류타입은 [불변 객체](https://ko.wikipedia.org/wiki/%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4)로 구현하자. 
- 밸류타입 변경 시 새로운 객체로 완전히 교체하도록 개발하는 걸 권장한다. 
- 이는 참조 투명성, 스레드 안정성, 예측불가능한 오류 예방 등의 효과가 있다. 


# CH 3 애그리거트

- 애그리거트는 복잡한 모델을 관리하는 기준(경계)을 제공한다. ex) 주문, 상품, 리뷰
- 이는 모델을 파악하는 것에도 도움을 준다.


## 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요하다.
- 그 주체가 바로 애그리거트의 **루트 엔티티**이다.
- 루트 엔티티를 두면 코드를 어느정도 통일할 수 있고, 일관성을 유지하는 효과도 있다.


## 트랜잭션 범위

- 성능상 트랜잭션의 범위는 작을수록 좋다. 
- 그리고 한 트랜잭션에서 동시에 두 개 이상의 애그리거트를 수정하면 충돌이 발생할 수 있으므로, 한 개의 애그리거트만 수정해야한다.

## 트랜잭션 범위와 애그리거트
- 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 한 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
- 이는 애그리거트 간 결합도를 낮추기 위함이다. 
- 또한 여러 애그리거트를 수정할 때는 도메인 레이어가 아닌 응용 레이어에서 수정하는 것이 애그리거트 간 결합도를 낮출 수 있어서 좋다.

- 그리고 코드 상에서도 도메인 레이어에서 한 애그리거트가 다른 애그리거트를 수정하지 못 하도록 설계하는 것도 안정성 면에서 좋다.

## ID를 이용한 애그리거트 참조
JPA와 같은 ORM 기술을 이용해 애그리거트 간 필드 참조를 하게 되면 의존 결합도가 높아져 다음과 같은 문제가 발생할 수 있다. 

- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움 (DB 변경 등)

이를 해결하기 위해 ID를 이용한 간접 참조 방식을 사용하기도 함.

ID 간접 참조를 이용하면 결합도를 낮추고 응집도를 높일 수 있고, 물리적인 연결을 제거하기 때문에 모델의 복잡도도 낮아진다.
또한, 한 애그리거트에서 다른 애그리거트를 수정하는 일도 코드 레벨에서 방지할 수 있다

## ID를 이용한 참조와 조회 성능
ID 간접 참조를 이용하면 ORM 사용 시 **lazy loading**과 같은 효과를 낸다.

그리고 lazy loading으로 인한 N + 1 문제도 발생할 수 있을 것이다. 이를 유의해서 각 DB 접근 기술 별로 해결방안을 찾는 것이 중요하다.

JPA의 경우 전용 조회 쿼리를 만들면 된다. 이렁게 하면 코드 구현에 시간을 조금 더 쓰긴 하지만, ID를 이용한 간접 참조는 확장성 면에서 긍정적이다.
