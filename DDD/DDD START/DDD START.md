# 개요

최범균님의 DDD START 책을 읽고 정리합니다.

- [개요](#개요)
- [CH 1 도메인 모델 시작](#ch-1-도메인-모델-시작)
  - [도메인](#도메인)
  - [도메인 모델 패턴](#도메인-모델-패턴)
  - [도메인 모델 도출](#도메인-모델-도출)
  - [문서화](#문서화)
  - [코드도 문서화이다](#코드도-문서화이다)
- [CH 2 아키텍처 개요](#ch-2-아키텍처-개요)
  - [DIP](#dip)
  - [DIP 주의점](#dip-주의점)
  - [도메인 영역의 주요 구성요소](#도메인-영역의-주요-구성요소)
  - [엔티티와 밸류](#엔티티와-밸류)
  - [밸류 타입 주의점](#밸류-타입-주의점)
- [CH 3 애그리거트](#ch-3-애그리거트)
  - [애그리거트 루트](#애그리거트-루트)
  - [트랜잭션 범위](#트랜잭션-범위)
  - [트랜잭션 범위와 애그리거트](#트랜잭션-범위와-애그리거트)
  - [ID를 이용한 애그리거트 참조](#id를-이용한-애그리거트-참조)
  - [ID를 이용한 참조와 조회 성능](#id를-이용한-참조와-조회-성능)
- [CH 4 리포지터리와 모델 구현(JPA중심)](#ch-4-리포지터리와-모델-구현jpa중심)
  - [@AttributeOverrides(@AttributeOverride())](#attributeoverridesattributeoverride)
  - [hibernate 기본 생성자를 protected로 선언해야 하는 이유](#hibernate-기본-생성자를-protected로-선언해야-하는-이유)
  - [JPA @Access와 엔티티 기능 중심 구현](#jpa-access와-엔티티-기능-중심-구현)
  - [AttributeConverter를 이용한 밸류 매핑 처리](#attributeconverter를-이용한-밸류-매핑-처리)
- [CH 6 응용 서비스와 표현 영역](#ch-6-응용-서비스와-표현-영역)
  - [표현 영역](#표현-영역)
  - [응용 서비스의 역할](#응용-서비스의-역할)
  - [도메인 로직 넣지 않기](#도메인-로직-넣지-않기)
  - [응용 서비스의 추상화(인터페이스와 클래스)](#응용-서비스의-추상화인터페이스와-클래스)

# CH 1 도메인 모델 시작

## 도메인

도메인의 사전적 정의는 다음과 같다.

**도메인** ([위키백과](https://ko.wikipedia.org/wiki/%EB%8F%84%EB%A9%94%EC%9D%B8_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B3%B5%ED%95%99)))
> 일반적인 요구사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역이다. 도메인 엔지니어링이라고도 알려져 있다.

결국 도메인은 소프트웨어로 해결하고자 하는 문제 영역을 의미한다.

## 도메인 모델 패턴

아래 도메인 모델은 마틴 파울러가 쓴 `엔터프라이즈 애플리케이션 아키텍쳐 패턴(PEAA)` 책의 도메인 모델 패턴을 의미한다.

**도메인 모델은 아키텍처상의 도메인 계층을 객체 지향 기법으로 구현하는 패턴을 말한다.**

| 계층(Layer)                                               | 설명                                                                                                       |
| --------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **사용자인터페이스**(UI) or <br> **표현** ( Presentation) | 사용자의 요청 처리 및 정보 제공                                                                            |
| 응용(Application)                                         | 사용자가 요청한 기능을 실행, **업무 로직을 직접 구현하지 않으며, 도메인 계층을 조합해서 기능을 수행한다.** |
| 도메인                                                    | 시스템이 제공할 도메인의 규칙을 구현                                                                       |
| 인프라스트럭처(infrastructor)                             | 데이터베이스나 메시지 시스템과 같은 외부 시스템과의 연동을 처리 : 인프라(DB 등)를 기준으로!                |

## 도메인 모델 도출

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
그리고 이는 요구사항에서 출발한다.

- enum으로 구현된 status 안에 isChangeable 메서드를 넣기보단 해당 status를 멤버로 쓰는 root 클래스에 넣자. <br> -> root 클래스 내에서 여러 멤버를 통해 isChangeable을 판별해야할 수도 있다.

## 문서화

- 문서화를 하는 주된 이유는 지식 공유이다.
- 실제 구현은 코드에 있으므로 모든 것은 코드를 보면 알 수 있지만, 코드는 상세한 내용을 모두 다루고 있기에 소프트웨어를 전체적으로 분석하려면 많은 시간이 필요하다. 따라서 정리된 문서를 참조하는 것이 전반적인 소프트웨어를 이해하는데 도움이 된다!
- 그리고 이후에 더 깊게 이해할 필요가 있는 부분을 코드로 분석해 나가면 된다.

## 코드도 문서화이다

- 코드를 보면서 도메인을 깊게 이해하게 되므로 코드도 문서화의 대상이다.
- 보기 좋은 코드를 작성하면서 도메인 관점에서도 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지고 문서로서 코드가 의미를 갖는다.

# CH 2 아키텍처 개요

보통 아키텍처를 설계할 때 다음과 같은 4개의 영역을 떠올릴 수 있다.
그리고 각 영역의 역할은 위 CH 1에서 본 내용과 같다.

- `표현`
- `응용`
- `도메인`
- `인프라스트럭처`

## DIP

DIP(의존관계 역전 원칙)를 이용하면 저수준 모듈에 의존하던 상태를 고수준 모듈에 의존하도록 변경해서 저수준 모듈이 변경되어도 유연하게 대처할 수 있다.

또한, 이는 인터페이스만 mocking하면 되기 때문에 테스트 코드를 작성하기에도 유리하다.

## DIP 주의점

DIP는 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.
단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들이는 것은 위험하다.

## 도메인 영역의 주요 구성요소

| 요소                                  | 설명                                                                                                                                                                                                                                                 |
| ------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **엔티티** <br> ENTITY                | 고유 식별자를 갖는 객체이며, 자신의 라이프사이클을 갖는다. 그리고 주문 등과 같이 도메인의 고유한 개념을 표현하고, 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.                                                         |
| **밸류** <br> VALUE                   | 고유의 식별자를 갖지 않는 객체. 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용됨(ex- OrderStatus, 주소(Address), )                                                                                                                       |
| **애그리거트** <br> AGGREGATE         | 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있음.                                                                                   |
| **리포지터리** <br> REPOSITORY        | 도메인 모델의 영속성을 처리. ex) JpaRepository, MabatisRepository                                                                                                                                                                                    |
| **도메인 서비스** <br> DOMAIN SERVICE | 특정 엔티티에 속하지 않은 도메인 로직을 제공. 예를 들어 `할인 금액 계산`은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 될텐데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하는 경우 도메인 서비스에서 로직을 구현한다. |

## 엔티티와 밸류

- 도메인 모델의 엔티티는 단순히 데이터를 담고 있는 데이터 구조라기보단 데이터와 함께 기능을 제공하는 객체이다. 도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화하여 데이터가 임의로 변경되는 것을 막는다.
- 이런 기능을 제공한다는 점에서 DB 테이블의 엔티티와 도메인 모델의 엔티티는 다르다는 것을 알 수 있다.

## 밸류 타입 주의점

  항상 밸류타입은 [불변 객체](https://ko.wikipedia.org/wiki/%EB%B6%88%EB%B3%80%EA%B0%9D%EC%B2%B4)로 구현하자.

- 밸류타입 변경 시 새로운 객체로 완전히 교체하도록 개발하는 걸 권장한다.
- 이는 참조 투명성, 스레드 안정성, 예측불가능한 오류 예방 등의 효과가 있다.

# CH 3 애그리거트

- 애그리거트는 복잡한 모델을 관리하는 기준(경계)을 제공한다. ex) 주문, 상품, 리뷰
- 이는 모델을 파악하는 것에도 도움을 준다.

## 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요하다.
- 그 주체가 바로 애그리거트의 **루트 엔티티**이다.
- 루트 엔티티를 두면 코드를 어느정도 통일할 수 있고, 일관성을 유지하는 효과도 있다.

## 트랜잭션 범위

- 성능상 트랜잭션의 범위는 작을수록 좋다.
- 그리고 한 트랜잭션에서 동시에 두 개 이상의 애그리거트를 수정하면 충돌이 발생할 수 있으므로, 한 개의 애그리거트만 수정해야한다.

## 트랜잭션 범위와 애그리거트

- 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 한 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미한다.
- 이는 애그리거트 간 결합도를 낮추기 위함이다.
- 또한 여러 애그리거트를 수정할 때는 도메인 레이어가 아닌 응용 레이어에서 수정하는 것이 애그리거트 간 결합도를 낮출 수 있어서 좋다.

- 그리고 코드 상에서도 도메인 레이어에서 한 애그리거트가 다른 애그리거트를 수정하지 못 하도록 설계하는 것도 안정성 면에서 좋다.

## ID를 이용한 애그리거트 참조

JPA와 같은 ORM 기술을 이용해 애그리거트 간 필드 참조를 하게 되면 의존 결합도가 높아져 다음과 같은 문제가 발생할 수 있다.

- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움 (DB 변경 등)

이를 해결하기 위해 ID를 이용한 간접 참조 방식을 사용하기도 함.

ID 간접 참조를 이용하면 결합도를 낮추고 응집도를 높일 수 있고, 물리적인 연결을 제거하기 때문에 모델의 복잡도도 낮아진다.
또한, 한 애그리거트에서 다른 애그리거트를 수정하는 일도 코드 레벨에서 방지할 수 있다

## ID를 이용한 참조와 조회 성능

ID 간접 참조를 이용하면 ORM 사용 시 **lazy loading**과 같은 효과를 낸다.

그리고 lazy loading으로 인한 N + 1 문제도 발생할 수 있을 것이다. 이를 유의해서 각 DB 접근 기술 별로 해결방안을 찾는 것이 중요하다.

JPA의 경우 전용 조회 쿼리를 만들면 된다. 이렁게 하면 코드 구현에 시간을 조금 더 쓰긴 하지만, ID를 이용한 간접 참조는 확장성 면에서 긍정적이다.

# CH 4 리포지터리와 모델 구현(JPA중심)

JPA를 이용한 구현 관련된 부분이여서 JPA에 관한 모든 걸 기록하지는 않고, 개인적으로 기록하고 싶은 부분만 기록한다.

## @AttributeOverrides(@AttributeOverride())

- 다음과 같이 `@Embedded`가 붙은 값 타입의 컬럼 이름을 변경할 수 있다.

``` java
// Orderer.java

public class Orderer {

  // '''
  @Embedded
  @AttributeOverrides(
    @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
  )
  private MemberId memberId;
}
// '''

```

``` java
// MemberId.java
@Embeddable
public class MemberId {
  @Column(name="member_id")
  private String id;
}

```

## hibernate 기본 생성자를 protected로 선언해야 하는 이유

- 하이버네이트는 클래스를 상속한 `프록시 객체`를 이용해서 지연 로딩을 구현한다.
- 이 경우 `프록시 클래스`에서 `상위 클래스의 기본 생성자`를 호출할 수 있어야 하므로 `지연 로딩 대상`이 되는 `@Entity`와 `@Embeddable`의 기본 생성자는 private이 아닌 `protected`로 지정해야 한다.

## JPA @Access와 엔티티 기능 중심 구현

``` java
@Entity
@Access(AccessType.FIELD)
public class Order {

  @EmbeddedId
  private OrderNo number;

  @Column(name = "state")
  @Enumerated(EnumType.STRING)
  private OrderState state;

  // ...
}

```

엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면, JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set 메서드를 구현하지 말아야한다.

JPA의 구현체인 hibernate는 `@Access`를 이용해 명시적으로 접근 방식을 지정하지 않으면 `@Id`나 `@EmbeddedId`가 어디에 위치했느냐에 따라 접근 방식을 결정한다.
`@Id`나 `@EmbeddedId`가 필드에 위치하면 필드 접근 방식을 선택하고, get메서드에 위치하면 메서드 접근 방식을 선택한다.

## AttributeConverter를 이용한 밸류 매핑 처리

JPA의 AttributeConverter를 이용해서 밸류 필드를 원하는 값으로 저장할 수 있다.

``` java
public interface AttributeConverter<X, Y> {
  public Y convertToDatabaseColumn (X attribute);
  public X convertToEntityAttribute (Y dbData);
}


@Convertor(autoApply = true)
public class MoneyConvertor implements AttributeConverter<Money, Integer> {

  @Override
  public Integer convertToDatabaseColumn(Money money) {
    if (money == null)
      return null;
    else
      return money.getValue();
  }

  @Override
  public Money convertToEntityAttribute (Integer value) {
    if (value == null) return null;
    else return new Money(value);
  }
}
```

`@Convertor(autoApply = true)`를 사용하면 JPA에서 자동으로 해당 타입을 convert해준다.
autoApply 속성이 false인 경우 다음과 같이 사용할 컨버터를 직접 지정할 수도 있다.

``` java

public class Order {
  @Column(name = "total_amounts")
  @Convert(converter = MoneyConverter.class)
  private Money totalAmounts;
}

```

# CH 6 응용 서비스와 표현 영역

다음과 같이 전형적인 아키텍처 설계에서 등장하는 `표현`, `응용`, `도메인`, `인프라스트럭처` 네 영역 중에 응용, 표현 영역에 대해서 구현, 역할 등 자세히 알아보자.

**클라이언트** -> **표현 영역** -> **응용 영역** -> **도메인 영역** -> **인프라 영역**

## 표현 영역

`표현 영역`은 클라이언트의 요청을 해석한다. 클라이언트가 보낸 요청을 받고 해당 요청의 URL, 요청 파라미터, 쿠키, 헤더 등을 해석하여 클라이언트가 어떤 기능을 실행하고 싶어 하는지 판단하고 그 기능을 제공하는 `응용 서비스`(응용 영역)를 실행한다. 

`응용 영역`에 위치한 `응용 서비스`는 실제 클라이언트가 원하는 기능을 제공하는 역할을 하며 기능을 수행하는데 필요한 파라미터를 전달받아 기능을 수행하고, 실행 결과를 리턴한다.

`응용 서비스`의 메서드가 요구하는 파라미터는 실제 클라이언트가 보내는 데이터와 일치하지 않을 수 있는데, 이 때는 `표현 영역`이 `응용 서비스`가 **요구하는 데이터 형식으로 요청 데이터를 변환하여 파라미터로 전달한다.**

## 응용 서비스의 역할

`응용 서비스`는 클라이언트의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 사용한다.
`응용 서비스`의 주요 역할은 도메인 객체를 사용해 클라이언트의 요청을 처리하는 것이며, `표현 영역` 입장에서 봤을 때 응용 서비스는 도메인 영역과 표현 영역을 연결해주는 통로인 **파사드(facade) 역할**을 한다.

또한, **도메인 객체 간의 실행 흐름을 제어**하는 역할을 하며 구체적으로는 **트랜잭션**을 처리, **접근 제어** 그리고 **이벤트 처리** 등이 있다. 모두 도메인 객체 간의 실행 흐름 제어에 관련된 역할이다.

**응용 서비스가 도메인 로직을 일부 구현하면 중복 코드 구현 등 코드 품질에 좋지않은 영향을 주니 주의하자.**

## 도메인 로직 넣지 않기

도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면, 중복 코드가 늘어나고 **코드의 응집성이 떨어져 코드 품질에 문제가 발생한다.**

코드 중복을 막기 위해 응용 서비스 영역에 별도의 보조 클래스를 만들 수 있지만 **애초에 도메인 영역에 해당 기능을 구현했다면, 새로 코드를 작성하지 않고 단지 해당 도메인이 제공하는 기능을 사용하기만 하면 된다.** 그리고 중복 코드를 제거함으로써 하나의 코드만 수정하면 되니 변경에 용이해진다.

## 응용 서비스의 추상화(인터페이스와 클래스)

응용 서비스를 구현할 때 추상화에 대해서 논쟁이 될 수 있다.

이는 다음과 같이 **인터페이스를 정의(추상화)가 필요하고 유용하게 사용할 수 있는 상황**을 생각해보면 쉽게 알 수 있다.

- **구현 클래스가 여러 개인 경우**
- **런타임에 구현 객체를 교체해야할 경우**

위 경우가 아니면 굳이 추상화를 해서 코드 수를 늘려 구조만 복잡해지는 상황이 발생할 수 있다.
따라서 인터페이스가 명확하게 필요하기 전까진 추상화를 하는 것이 좋은 설계라고 볼 수 없다.

그리고 TDD에서는 구현 순서에 따라 인터페이스가 필요한 순간이 있겠지만, 이는 Mockito와 같이 테스트용 가짜 객체를 만들 수 있으니 응용 서비스에 대한 인터페이스가 없어도 표현 영역을 테스트할 수 있다고 한다.


결과적으로 응용 서비스에 대한 인터페이스 필요성을 약화시킨다.