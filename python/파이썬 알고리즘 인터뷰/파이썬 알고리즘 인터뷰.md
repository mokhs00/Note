- [개요](#개요)
- [3장 파이썬](#3장-파이썬)
  - [PEP 란?](#pep-란)
  - [파이썬 문법](#파이썬-문법)
    - [`인덴트`](#인덴트)
    - [`네이밍 컨벤션`](#네이밍-컨벤션)
    - [`타입 힌트`](#타입-힌트)
    - [`리스트 컴프리헨션`](#리스트-컴프리헨션)
    - [`제네레이터(Generator)`](#제네레이터generator)
    - [enumerate](#enumerate)
    - [나눗셈 연산자](#나눗셈-연산자)
    - [print](#print)
    - [pass](#pass)
    - [locals](#locals)
    - [pprint](#pprint)
- [4장 빅오, 자료형](#4장-빅오-자료형)
  - [빅오](#빅오)
  - [상한과 최악](#상한과-최악)
  - [분할 상환 분석](#분할-상환-분석)
  - [병렬화](#병렬화)
  - [자료형](#자료형)
    - [숫자](#숫자)
    - [임의 정밀도란?](#임의-정밀도란)
    - [매핑](#매핑)
    - [집합](#집합)
    - [시퀀스(Sequence)](#시퀀스sequence)
    - [원시타입은 없다 모든 것이 객체](#원시타입은-없다-모든-것이-객체)
    - [객체](#객체)
- [5장 리스트, 딕셔너리](#5장-리스트-딕셔너리)
- [6장 문자열 조작](#6장-문자열-조작)
  - [팰린드롬](#팰린드롬)
  - [정렬](#정렬)
  - [유용한 함수들](#유용한-함수들)
    - [isalnum()](#isalnum)
    - [lower()](#lower)
    - [re.sub()](#resub)
    - [isdigit()](#isdigit)
    - [split()](#split)

# 개요

파이썬 알고리즘 인터뷰 책(방삭길 지음)을 공부하며 내용을 정리합니다.

# 3장 파이썬

## PEP 란?

파이썬의 개발은 `PEP`(Python Enhancement Proposals)라고 불리는 파이썬 개선 제안서 프로세스를 통해서 진행된다.
**코딩 스타일 가이드에 해당하는** `PEP 8` 같이 뒤에 특정 코드가 붙으며, 이는 나름의 규칙이 있다고 한다.

## 파이썬 문법

파이썬은 기본적으로 `파이썬다운 방식(Pythonic Way)`에 대한 자부심이 있다고 전해지고, 철학도 있다.
그로 인해 파이썬은 기본적으로 몇가지 원칙을 따르는데 이는 다음과 같다.
참고로 원칙을 지키지 않아도 되지만, 파이참같은 IDE를 사용하면 자동으로 경고를 띄워준다.

### `인덴트`

- 파이썬의 인덴트는 **PEP 8**에 따라 `공백 4칸`을 원칙으로 한다. 이는 어느정도 원칙을 강제함으로써 코드가 다른 행과 구분되고 깔끔해지는 효과가 있다.

### `네이밍 컨벤션`

- 파이썬은 PEP 8 및 파이썬 철학에 따라 변수명 네임이 컨벤션을 `스네이크 케이스`를 기본으로 한다.

### `타입 힌트`

- 파이썬에서도 다음과 같이 타입 힌트를 기술해서 타입을 명시할 수 있다.
- 하지만, 실제로 강제 규약이 아니다보니 여전히 동적으로 타입이 할당될 수 있으므로 주의가 필요하다.

    ``` python
    name: str = "MOKHS"
    age: int = 22
     ```

### `리스트 컴프리헨션`

- 파이썬은 다음과 같이 `map`, `filter`와 같은 함수형 기능과 람다 표현식을 지원한다.

    ``` python
    >>> list(map(lambda x: x + 10, [1, 2, 3]))
    [11, 12, 13]
    ```

- **리스트 컴프리헨션**을 사용하면 다음과 같은 표현도 가능하다.

    ``` python
    >>> [n + 10 for n in range(1, 1 + 3) if n % 2 == 1]
    [11, 13]
    ```

- 리스트 컴프리헨션은 다방면에서 유용하게 활용되며, **잘 사용한다면 map, filter를 섞어서 사용하는 것보다 가독성이 좋아진다.**
- **하지만 이 또한 복잡한 로직을 무리하게 사용하면 가독성을 떨어뜨릴 수있으니 주의해야한다.**
- 표현식은 2개 이상 사용하지 않는 것을 권장한다.

### `제네레이터(Generator)`

- 제네레이터란 루프의 **반복 동작을 제어**할 수 있는 루틴 형태를 말하며, 대표적인 제네레이터로는 `range()`가 있다.
  - `yield` 구문을 이용해 제네레이터를 리턴할 수 있다.
  - `yield`는 사전적 의미로 `양보하다` 이다.
  - `yield`는 제네레이터가 여기까지 실행중이던 값을 내보낸다는 의미이고, 반면에 `return` 구문을 만나면 값을 리턴하고 모든 함수의 동작을 종료한다.
- 제네레이터 없이 코드를 작성 시, 임의의 조건으로 1억 개 숫자를 만드는 코드는 숫자 1억 개를 메모리에 보관하고 있어야 한다.
- 그러나 제네레이터를 사용하면? **훨씬 적은 메모리를 이용해서 필요할 때만 숫자를 가져올 수 있다** 다음 코드를 살펴보면 이해가 빠르다.

    ``` python
    >>> a = [n for n in range(100000)]
    >>> b = range(100000)
    >>> len(a) # a와 b의 길이는 같다.
    100000
    >>> len(b)
    100000
    >>> import sys
    >>> sys.getsizeof(a) # 각각 a와 b가 차지하는 메모리 크기는 다르다.
    824464
    >>> sys.getsizeof(b)
    48
    ```

- 예시는 다음과 같다.
  - yield로 값을 리턴하면 generator를 반환하는 것을 볼 수 있다.

      ``` python
      >>> def get_number():
      ...     n = 0
      ...     while True:
      ...             n+=1
      ...             yield n
      ...
      >>> get_number()
      <generator object get_number at 0x000001EA6FBA2348>
      ```

  - next(generator) 를 실행해서 다음 값을 가져올 수 있다.

      ``` python
      >>> a = get_number()
      >>> a
      <generator object get_number at 0x000001EA6FBA25C8>
      >>> next(a)
      1
      >>> next(a)
      2
      ```

### enumerate

- `enumerate()`는 `열거하다`는 뜻의 함수이다.
- 여러 가지 자료형(list, set, tuple 등)을 인덱스를 포함한 `enumerate` 객체로 리턴한다.
- 인덱스를 자동으로 부여해주기 때문에 매우 편리하게 사용할 수 있다.
- 사용법은 다음과 같다.

  ``` python
  >>> a = [n for n in range(3)]
  >>> e = enumerate(a)
  >>> list(e)
  [(0, 0), (1, 1), (2, 2)]
  ```

  ``` python
  >>> for i, v in enumerate(a):
  ...     print(i, v)
  ...
  0 0
  1 1
  2 2
  ```

### 나눗셈 연산자

- 파이썬에는 `/` 과 `//`가 있다. 이는 이전에 파이썬 2에서 사용하던 방식 때문에 여러개로 나눠진 것인데,
- 간단하게 `/`는 나누기이고, `//` 는 몫을 구하는 연산자이다. `int(5 / 3)` 은 `5 // 3`과 동일하다. 좀 더 편하게 쓸 수 있는 느낌

  ``` python
  # Python 3+
  >>> 5 / 3
  1.6666666666666667
  # Python 2 이하
  >>> 5 // 3
  1
  >>> print(5 // 3, int(5 / 3))
  1 1
  ```

### print

- 다음과 같이 print는 다양한 방법이 있다

``` python
>>> print(1, 2 , sep=', ') # 구분자 추가 가능
1, 2
>>> print(1, end=' ::\n') # 개행 제어 가능
1 :: 
>>> print(' '.join(['1','2'])) # list join 가능
1 2
>>> print('{0}: {1}'.format(1,2)) # format 가능
1: 2
>>> print('{}: {}'.format(1,2)) # format 숫자 생략 가능
1: 2
>>> idx = 1
>>> item = 'pen'
>>> print(f'{idx}: {item}') # 파이썬 3.6+에서만 지원! f-string(formated string literal) :  %, .format보다 간결하고 직관적이며 속도도 빠름
1: pen
>>>
```

### pass

- 파이썬에서는 함수 내부를 구현하지 않으면 인덴트 오류로 전체 코드가 동작하지 않을 수 있다.
- `pass`는 코딩할 때 전체 골격을 잡아놓고 내부 구현은 차근차근 만들고 싶을 때 유용하다.
- 파이썬에서 `pass`는 널(Null) 연산으로 아무것도 하지 않는다.
- 다음 예시를 참고하자

  ``` python
  class MyClass(object):
    def my_method(self):
      pass
  ```

### locals

- `locals()`는 로컬 심볼 테이블 딕셔너리를 가져오는 메서드이다.
- 디버깅 시 도움이 될 수 있는 강력한 기능

### pprint

- 줄바꿈 처리 해줘서 가독성이 높아진다.

``` python
import pprint
>>> pprint.pprint(locals())
{'__annotations__': {},
 '__builtins__': <module 'builtins' (built-in)>,
 '__doc__': None,
 '__loader__': <class '_frozen_importlib.BuiltinImporter'>,
 '__name__': '__main__',
 '__package__': None,
 '__spec__': None,
 'a': [0, 1, 2],
 'b': range(0, 100000),
 'e': <enumerate object at 0x000001EA6FBA3BD8>,
 'get_number': <function get_number at 0x000001EA6FBA4798>,
 'i': 2,
 'idx': 1,
 'item': 'pen',
 'pprint': <module 'pprint' from 'C:\\Users\\kim\\AppData\\Local\\Programs\\Python\\Python37\\lib\\pprint.py'>,
 'sys': <module 'sys' (built-in)>,
 'v': 2}
```

# 4장 빅오, 자료형

- 알고리즘은 대부분 `시간과 공간이 트레이드오프(Space-Time Tradeoff) 관계이다.
- 이는 알고리즘의 실행 시간이 빠르면, 공간을 많이 차지하고, 공간을 적게 차지하면, 실행 시간이 빠르다는 말이다.
- 예외적으로 실행 시간이 빠르면서 공간을 적게 차지하는 알고리즘도 존재한다.
- 먼저, 알고리즘의 수학적 표기 방법인 `빅오`에 대해서 알아보자

## 빅오

- `빅오(big-O)`란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법을 말한다.
- 또한, `점근적 실행 시간(Asymptotic Running Time)`을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나이다.
  - 점근적 실행 시간을 달리 말하면 `시간 복잡도`라고 할 수 있다.
- 빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 상수는 무시한다.
  - 예를 들어 4n^2이라면 n^2으로친다.
- `빅오(big-O)`는 입력값이 커질 때 알고리즘의 `실행시간(시간 복잡도)`과 함께 `공간 요구사항(공간 복잡도)` 이 어떻게 증가하는지를 뷴류하는데 사용되며, `알고리즘의 효율성을 분석`하는 데에도 유용하게 활용된다.

## 상한과 최악

- 빅오(O)는 `상한(Upper Bound)`를 의미한다. 즉 어떤 함수의 실행 시간이 가장 늦을 때를 의미한다.
-  이외에도 `하한(Lower Bound)`을 나타내는 `빅오메가(Ω)`, 평균을 나타내는 `빅세타(θ)`가 있다. 
-  학계와 달리 업계에서는 빅세타와 빅오를 하나로 묶어서 단순화해서 표현하려는 경향이 있고한다. 보통 평균적인 시간보다는 상한 시간으로 단순화 해서 표현하고, **이는 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않다고도 한다.**
- 그리고, `상한`은 `최악`과는 다른 개념이므로 주의해야한다. 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 `'적당히 정확하게'` 표현하는 방법일 뿐이지 최악, 평균적인 경우의 시간복잡도와는 아무런 관계가 없다.

위 내용들을 토대로 빅오에 대해 정리하면 다음과 같다.

``` js
`빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.`
```


## 분할 상환 분석

- 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, `알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유`로 본할 `상환 분석 방법`이 등장하게 되었다.
- `분할 상환 분석(Amortized Analysis)`은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나이다.
- 예를 들어 동적 배열에서 `더블링(배열 크기를 2배로 늘리는)`이 일어나는 일은 어쩌다 한 번뿐이지만, 이로 인해 `아이템 삽입 시간 복잡도는 O(n)`이라고 얘기하는 것은 지나치게 비관적이고 정확하지도 않다.
- 따라서 이 경우 `분할 상환` 또는 `상각`이라고 표현하는 `최악의 경우`를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다. 이렇게 할 경우 동적 배열의 삽입 시 시간복잡도는 O(1)이 된다.
- 이 방법은 최근에 시간 복잡도를 분석할 때 매우 보편적으로 널리 사용되는 방법이다.

## 병렬화

- 당연한 얘기지만 병렬화를 이용해서 알고리즘의 실행 속도를 높일 수 있다. 최근에 딥러닝과 함께 GPU를 이용해서 병렬 연산을 하는 걸 볼 수 있다.
- 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지도 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도가 되었다고 한다.

## 자료형

파이썬의 자료형에 대해서 알아보자.

### 숫자

- 파이썬은 숫자 정수형으로 int만 제공한다.
- 원래 파이썬 2 버전까지는 int와 long을 각각 별도로 제공했지만 PEP 237에 의해서 2.4 버전 이후로는 int가 충분하지 않으면 자동으로 long으로 변경되는 구조가 되었다. 이후 버전 3부터는 아예 int 단일형으로 통일되었고, `임의 정밀도`를 지원한다. 이후 파이썬은 더이상 `고정 정밀도` 정수형을 지원하지 않게되었다.

### 임의 정밀도란?

- 쉽게 말해 무제한 자릿수를 제공하는 정수형을 말한다.

### 매핑

- 키와 자료형으로 구성된 자료형
- ex) **dict(딕셔너리)**

### 집합

- 중복된 값 허용 x
- ex) set

### 시퀀스(Sequence)

- 우리말로 하면 `수열` 어떤 특정 대상의 순서 있는 나열을 의미
- 시퀀스 타입은 불변(immutable)과 가변(mutable)로 구분한다.
- 참고로 불변과 가변에 대한 것은 메모리 주소의 관점에서 측정한다.
- ex) str, list

### 원시타입은 없다 모든 것이 객체

- 파이썬에는 원시타입이 없고 모든 것이 객체이다.
- 이는 `편리한 기능 제공`에 우선순위를 둔 파이썬의 특징이다.
- 객체로 타입을 표현함으로써 자바의 래퍼 클래스처럼 여러가지 기능이 제공된다

### 객체

파이썬은 자료형은 모두 객체로 이루어져 있고, 크게 불변/가변 으로 나뉜다. 이를 정리하면 다음과 같다.

| 클래스 | 불변 객체 여부 |
| ------ | -------------- |
| bool   | O              |
| int    | O              |
| float  | O              |
| list   | X              |
| tuple  | O              |
| str    | O              |
| set    | X              |
| dict   | X              |

# 5장 리스트, 딕셔너리

# 6장 문자열 조작

## 팰린드롬

`팰린드롬`이란 앞뒤가 똑같은 단어나 문장을 말한다.
파이썬으로 모두 소문자인 문자열이 팰린드롬인지 판단하는 코드는 다음과 같다.

``` python
def is_palindrome(s: list) -> bool:
    while len(s) > 1:
        if s.pop(0) != s.pop():
            return False
    return True


s = input()

strs = []

for char in s:
    if char.isalnum():
        strs.append(char.lower())

print(is_palindrome(strs))
```

해당 문제는 리스트로도 충분히 풀 수 있지만, 데크(Deque)를 명시적으로 선언하면 좀 더 속도를 높일 수 있다.
**리스트의 pop()은 O(n)인 데 반해, deque의 popleft()는 O(1)이기 때문이다.**
위 코드에서 list를 deque로 변경한 코드는 다음과 같다.

``` python
import collections


def is_palindrome(s: collections.deque) -> bool:
    while len(s) > 1:
        if s.popleft() != s.pop():
            return False
    return True


s = input()

strs = collections.deque()

for char in s:
    if char.isalnum():
        strs.append(char.lower())

print(is_palindrome(strs))
```

파이썬의 슬라이싱을 이용하면 이는 내부적으로 c로 구현되어있기 때문에 속도를 좀 더 높일 수 있다. 코드 또한 매우 간결해진다.

``` python

def is_palindrome(s: str) -> bool:
  s = s.lower()

  # 불필요한 문자를 필터링
  s = re.sub('[^a-z0-9]', '', s)

  return s == s[::-1]


```

## 정렬

람다식과 `sort()`를 이용하면 여러 조건을 가지고 정렬할 수 있다.
다음 예시는 letters에 들어있는 문자열[1:]을 키로 먼저 정렬하고 동일할 경우, 문자열[0]을 기준으로 정렬한다.
즉 앞에서 부터 우선순위 조건이다.

``` python
letters.sort(key=lambda x: (x.split()[1:], x.split()[0]))
```

## 유용한 함수들

### isalnum()

영문자, 숫자 여부를 판별하는 함수.

### lower()

모두 소문자로 변환

### re.sub()

- 정규식을 활용해서 replace 가능
- 전처리 작업에 유용하다.

``` python
re.sub('[^a-z0-9]', '', s)
re.sub(r')


```

### isdigit()

숫자 여부를 판별

### split()

split()은 매개변수로 아무런 값을 입력해주지 않으면 공백을 기본으로 문자열을 나눈다.
