- [개요](#개요)
- [3장 파이썬](#3장-파이썬)
  - [PEP 란?](#pep-란)
  - [파이썬 문법](#파이썬-문법)
    - [`인덴트`](#인덴트)
    - [`네이밍 컨벤션`](#네이밍-컨벤션)
    - [`타입 힌트`](#타입-힌트)
    - [`리스트 컴프리헨션`](#리스트-컴프리헨션)
    - [`제네레이터(Generator)`](#제네레이터generator)
    - [enumerate](#enumerate)
    - [나눗셈 연산자](#나눗셈-연산자)
    - [print](#print)
    - [pass](#pass)
    - [locals](#locals)
    - [pprint](#pprint)
- [4장 빅오, 자료형](#4장-빅오-자료형)
  - [빅오](#빅오)
  - [상한과 최악](#상한과-최악)
  - [분할 상환 분석](#분할-상환-분석)
  - [병렬화](#병렬화)
  - [자료형](#자료형)
    - [숫자](#숫자)
    - [임의 정밀도란?](#임의-정밀도란)
    - [매핑](#매핑)
    - [집합](#집합)
    - [시퀀스(Sequence)](#시퀀스sequence)
    - [원시타입은 없다 모든 것이 객체](#원시타입은-없다-모든-것이-객체)
    - [객체](#객체)
- [5장 리스트, 딕셔너리](#5장-리스트-딕셔너리)
  - [리스트](#리스트)
  - [딕셔너리](#딕셔너리)
  - [딕셔너리 모듈](#딕셔너리-모듈)
    - [defaultdict](#defaultdict)
    - [Counter 객체](#counter-객체)
- [6장 문자열 조작](#6장-문자열-조작)
  - [팰린드롬](#팰린드롬)
  - [가장 긴 팰린드롬 부분 문자열](#가장-긴-팰린드롬-부분-문자열)
  - [문자열 뒤집기](#문자열-뒤집기)
  - [정렬](#정렬)
  - [파이썬이 사용하는 정렬 알고리즘 : 팀소트(Timsort)](#파이썬이-사용하는-정렬-알고리즘--팀소트timsort)
  - [애너그램](#애너그램)
  - [유용한 함수들](#유용한-함수들)
    - [isalnum()](#isalnum)
    - [lower()](#lower)
    - [re.sub()](#resub)
    - [isdigit()](#isdigit)
    - [split()](#split)
    - [max()](#max)
    - [divmod()](#divmod)
- [7장 배열](#7장-배열)
  - [투 포인터](#투-포인터)
  - [최댓값과 최솟값](#최댓값과-최솟값)
- [8장 연결 리스트](#8장-연결-리스트)
  - [런너 기법](#런너-기법)

# 개요

파이썬 알고리즘 인터뷰 책(방삭길 지음)을 공부하며 내용을 정리합니다.

# 3장 파이썬

## PEP 란?

파이썬의 개발은 `PEP`(Python Enhancement Proposals)라고 불리는 파이썬 개선 제안서 프로세스를 통해서 진행된다.
**코딩 스타일 가이드에 해당하는** `PEP 8` 같이 뒤에 특정 코드가 붙으며, 이는 나름의 규칙이 있다고 한다.

## 파이썬 문법

파이썬은 기본적으로 `파이썬다운 방식(Pythonic Way)`에 대한 자부심이 있다고 전해지고, 철학도 있다.
그로 인해 파이썬은 기본적으로 몇가지 원칙을 따르는데 이는 다음과 같다.
참고로 원칙을 지키지 않아도 되지만, 파이참같은 IDE를 사용하면 자동으로 경고를 띄워준다.

### `인덴트`

- 파이썬의 인덴트는 **PEP 8**에 따라 `공백 4칸`을 원칙으로 한다. 이는 어느정도 원칙을 강제함으로써 코드가 다른 행과 구분되고 깔끔해지는 효과가 있다.

### `네이밍 컨벤션`

- 파이썬은 PEP 8 및 파이썬 철학에 따라 변수명 네임이 컨벤션을 `스네이크 케이스`를 기본으로 한다.

### `타입 힌트`

- 파이썬에서도 다음과 같이 타입 힌트를 기술해서 타입을 명시할 수 있다.
- 하지만, 실제로 강제 규약이 아니다보니 여전히 동적으로 타입이 할당될 수 있으므로 주의가 필요하다.

    ``` python
    name: str = "MOKHS"
    age: int = 22
     ```

### `리스트 컴프리헨션`

- 파이썬은 다음과 같이 `map`, `filter`와 같은 함수형 기능과 람다 표현식을 지원한다.

    ``` python
    >>> list(map(lambda x: x + 10, [1, 2, 3]))
    [11, 12, 13]
    ```

- **리스트 컴프리헨션**을 사용하면 다음과 같은 표현도 가능하다.

    ``` python
    >>> [n + 10 for n in range(1, 1 + 3) if n % 2 == 1]
    [11, 13]
    ```

- 리스트 컴프리헨션은 다방면에서 유용하게 활용되며, **잘 사용한다면 map, filter를 섞어서 사용하는 것보다 가독성이 좋아진다.**
- **하지만 이 또한 복잡한 로직을 무리하게 사용하면 가독성을 떨어뜨릴 수있으니 주의해야한다.**
- 표현식은 2개 이상 사용하지 않는 것을 권장한다.

### `제네레이터(Generator)`

- 제네레이터란 루프의 **반복 동작을 제어**할 수 있는 루틴 형태를 말하며, 대표적인 제네레이터로는 `range()`가 있다.
  - `yield` 구문을 이용해 제네레이터를 리턴할 수 있다.
  - `yield`는 사전적 의미로 `양보하다` 이다.
  - `yield`는 제네레이터가 여기까지 실행중이던 값을 내보낸다는 의미이고, 반면에 `return` 구문을 만나면 값을 리턴하고 모든 함수의 동작을 종료한다.
- 제네레이터 없이 코드를 작성 시, 임의의 조건으로 1억 개 숫자를 만드는 코드는 숫자 1억 개를 메모리에 보관하고 있어야 한다.
- 그러나 제네레이터를 사용하면? **훨씬 적은 메모리를 이용해서 필요할 때만 숫자를 가져올 수 있다** 다음 코드를 살펴보면 이해가 빠르다.

    ``` python
    >>> a = [n for n in range(100000)]
    >>> b = range(100000)
    >>> len(a) # a와 b의 길이는 같다.
    100000
    >>> len(b)
    100000
    >>> import sys
    >>> sys.getsizeof(a) # 각각 a와 b가 차지하는 메모리 크기는 다르다.
    824464
    >>> sys.getsizeof(b)
    48
    ```

- 예시는 다음과 같다.
  - yield로 값을 리턴하면 generator를 반환하는 것을 볼 수 있다.

      ``` python
      >>> def get_number():
      ...     n = 0
      ...     while True:
      ...             n+=1
      ...             yield n
      ...
      >>> get_number()
      <generator object get_number at 0x000001EA6FBA2348>
      ```

  - next(generator) 를 실행해서 다음 값을 가져올 수 있다.

      ``` python
      >>> a = get_number()
      >>> a
      <generator object get_number at 0x000001EA6FBA25C8>
      >>> next(a)
      1
      >>> next(a)
      2
      ```

### enumerate

- `enumerate()`는 `열거하다`는 뜻의 함수이다.
- 여러 가지 자료형(list, set, tuple 등)을 인덱스를 포함한 `enumerate` 객체로 리턴한다.
- 인덱스를 자동으로 부여해주기 때문에 매우 편리하게 사용할 수 있다.
- 사용법은 다음과 같다.

  ``` python
  >>> a = [n for n in range(3)]
  >>> e = enumerate(a)
  >>> list(e)
  [(0, 0), (1, 1), (2, 2)]
  ```

  ``` python
  >>> for i, v in enumerate(a):
  ...     print(i, v)
  ...
  0 0
  1 1
  2 2
  ```

### 나눗셈 연산자

- 파이썬에는 `/` 과 `//`가 있다. 이는 이전에 파이썬 2에서 사용하던 방식 때문에 여러개로 나눠진 것인데,
- 간단하게 `/`는 나누기이고, `//` 는 몫을 구하는 연산자이다. `int(5 / 3)` 은 `5 // 3`과 동일하다. 좀 더 편하게 쓸 수 있는 느낌

  ``` python
  # Python 3+
  >>> 5 / 3
  1.6666666666666667
  # Python 2 이하
  >>> 5 // 3
  1
  >>> print(5 // 3, int(5 / 3))
  1 1
  ```

### print

- 다음과 같이 print는 다양한 방법이 있다

``` python
>>> print(1, 2 , sep=', ') # 구분자 추가 가능
1, 2
>>> print(1, end=' ::\n') # 개행 제어 가능
1 :: 
>>> print(' '.join(['1','2'])) # list join 가능
1 2
>>> print('{0}: {1}'.format(1,2)) # format 가능
1: 2
>>> print('{}: {}'.format(1,2)) # format 숫자 생략 가능
1: 2
>>> idx = 1
>>> item = 'pen'
>>> print(f'{idx}: {item}') # 파이썬 3.6+에서만 지원! f-string(formated string literal) :  %, .format보다 간결하고 직관적이며 속도도 빠름
1: pen
>>>
```

### pass

- 파이썬에서는 함수 내부를 구현하지 않으면 인덴트 오류로 전체 코드가 동작하지 않을 수 있다.
- `pass`는 코딩할 때 전체 골격을 잡아놓고 내부 구현은 차근차근 만들고 싶을 때 유용하다.
- 파이썬에서 `pass`는 널(Null) 연산으로 아무것도 하지 않는다.
- 다음 예시를 참고하자

  ``` python
  class MyClass(object):
    def my_method(self):
      pass
  ```

### locals

- `locals()`는 로컬 심볼 테이블 딕셔너리를 가져오는 메서드이다.
- 디버깅 시 도움이 될 수 있는 강력한 기능

### pprint

- 줄바꿈 처리 해줘서 가독성이 높아진다.

``` python
import pprint
>>> pprint.pprint(locals())
{'__annotations__': {},
 '__builtins__': <module 'builtins' (built-in)>,
 '__doc__': None,
 '__loader__': <class '_frozen_importlib.BuiltinImporter'>,
 '__name__': '__main__',
 '__package__': None,
 '__spec__': None,
 'a': [0, 1, 2],
 'b': range(0, 100000),
 'e': <enumerate object at 0x000001EA6FBA3BD8>,
 'get_number': <function get_number at 0x000001EA6FBA4798>,
 'i': 2,
 'idx': 1,
 'item': 'pen',
 'pprint': <module 'pprint' from 'C:\\Users\\kim\\AppData\\Local\\Programs\\Python\\Python37\\lib\\pprint.py'>,
 'sys': <module 'sys' (built-in)>,
 'v': 2}
```

# 4장 빅오, 자료형

- 알고리즘은 대부분 `시간과 공간이 트레이드오프(Space-Time Tradeoff) 관계이다.
- 이는 알고리즘의 실행 시간이 빠르면, 공간을 많이 차지하고, 공간을 적게 차지하면, 실행 시간이 빠르다는 말이다.
- 예외적으로 실행 시간이 빠르면서 공간을 적게 차지하는 알고리즘도 존재한다.
- 먼저, 알고리즘의 수학적 표기 방법인 `빅오`에 대해서 알아보자

## 빅오

- `빅오(big-O)`란 입력값이 무한대로 향할때 함수의 상한을 설명하는 수학적 표기 방법을 말한다.
- 또한, `점근적 실행 시간(Asymptotic Running Time)`을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나이다.
  - 점근적 실행 시간을 달리 말하면 `시간 복잡도`라고 할 수 있다.
- 빅오로 시간 복잡도를 표현할 때는 최고차항만을 표기하며, 상수는 무시한다.
  - 예를 들어 4n^2이라면 n^2으로친다.
- `빅오(big-O)`는 입력값이 커질 때 알고리즘의 `실행시간(시간 복잡도)`과 함께 `공간 요구사항(공간 복잡도)` 이 어떻게 증가하는지를 분류하는데 사용되며, `알고리즘의 효율성을 분석`하는 데에도 유용하게 활용된다.

## 상한과 최악

- 빅오(O)는 `상한(Upper Bound)`를 의미한다. 즉 어떤 함수의 실행 시간이 가장 늦을 때를 의미한다.
- 이외에도 `하한(Lower Bound)`을 나타내는 `빅오메가(Ω)`, 평균을 나타내는 `빅세타(θ)`가 있다.
- 학계와 달리 업계에서는 빅세타와 빅오를 하나로 묶어서 단순화해서 표현하려는 경향이 있다고 한다. 보통 평균적인 시간보다는 상한 시간으로 단순화 해서 표현하고, **이는 매번 구분하는 것이 번거롭고 혼동되기도 하며 또한 상한으로만 표현하는 방법이 틀리지 않다고도 한다.**
- 그리고, `상한`은 `최악`과는 다른 개념이므로 주의해야한다. 빅오 표기법은 정확하게 쓰기에는 너무 길고 복잡한 함수를 `'적당히 정확하게'` 표현하는 방법일 뿐이지 최악, 평균적인 경우의 시간복잡도와는 아무런 관계가 없다.

위 내용들을 토대로 빅오에 대해 정리하면 다음과 같다.

``` js
`빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 상한을 나타낸다.`
```

## 분할 상환 분석

- 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, `알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유`로 `분할 상환 분석 방법`이 등장하게 되었다.
- `분할 상환 분석(Amortized Analysis)`은 빅오와 함께 함수의 동작을 설명할 때 중요한 분석 방법 중 하나이다.
- 예를 들어 동적 배열에서 `더블링(배열 크기를 2배로 늘리는)`이 일어나는 일은 어쩌다 한 번뿐이지만, 이로 인해 `아이템 삽입 시간 복잡도는 O(n)`이라고 얘기하는 것은 지나치게 비관적이고 정확하지도 않다.
- 따라서 이 경우 `분할 상환` 또는 `상각`이라고 표현하는 `최악의 경우`를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다. 이렇게 할 경우 동적 배열의 삽입 시 시간복잡도는 O(1)이 된다.
- 이 방법은 최근에 시간 복잡도를 분석할 때 매우 보편적으로 널리 사용되는 방법이다.

## 병렬화

- 당연한 얘기지만 병렬화를 이용해서 알고리즘의 실행 속도를 높일 수 있다. 최근에 딥러닝과 함께 GPU를 이용해서 병렬 연산을 하는 걸 볼 수 있다.
- 알고리즘 자체의 시간 복잡도 외에도 알고리즘이 병렬화가 가능한지도 근래에 알고리즘의 우수성을 평가하는 매우 중요한 척도가 되었다고 한다.

## 자료형

파이썬의 자료형에 대해서 알아보자.

### 숫자

- 파이썬은 숫자 정수형으로 int만 제공한다.
- 원래 파이썬 2 버전까지는 int와 long을 각각 별도로 제공했지만 PEP 237에 의해서 2.4 버전 이후로는 int가 충분하지 않으면 자동으로 long으로 변경되는 구조가 되었다. 이후 버전 3부터는 아예 int 단일형으로 통일되었고, `임의 정밀도`를 지원한다. 이후 파이썬은 더이상 `고정 정밀도` 정수형을 지원하지 않게되었다.

### 임의 정밀도란?

- 쉽게 말해 무제한 자릿수를 제공하는 정수형을 말한다.

### 매핑

- 키와 자료형으로 구성된 자료형
- ex) **dict(딕셔너리)**

### 집합

- 중복된 값 허용 x
- ex) set

### 시퀀스(Sequence)

- 우리말로 하면 `수열` 어떤 특정 대상의 순서 있는 나열을 의미
- 시퀀스 타입은 불변(immutable)과 가변(mutable)로 구분한다.
- 참고로 불변과 가변에 대한 것은 메모리 주소의 관점에서 측정한다.
- ex) str, list

### 원시타입은 없다 모든 것이 객체

- 파이썬에는 원시타입이 없고 모든 것이 객체이다.
- 이는 `편리한 기능 제공`에 우선순위를 둔 파이썬의 특징이다.
- 객체로 타입을 표현함으로써 자바의 래퍼 클래스처럼 여러가지 기능이 제공된다

### 객체

파이썬은 자료형은 모두 객체로 이루어져 있고, 크게 불변/가변 으로 나뉜다. 이를 정리하면 다음과 같다.

| 클래스 | 불변 객체 여부 |
| ------ | -------------- |
| bool   | O              |
| int    | O              |
| float  | O              |
| list   | X              |
| tuple  | O              |
| str    | O              |
| set    | X              |
| dict   | X              |

# 5장 리스트, 딕셔너리

## 리스트

- 순서대로 저장하는 `시퀀스`이자
- 변경 가능한 목록(Mutable List)를 말한다.
- CPython에서 리스트는 요소에 대한 포인터 목록을 갖고 있는 구조체이다. 그래서 여러 자료형을 담을 수 있고,
- 리스트에 요소를 추가하거나 조작하기 시작하면 목록의 사이즈를 조절해 나가는 형태로 구현되어있다
- 배열과 연결 리스트를 합친듯한 강력한 기능을 제공한다.

리스트의 연산 함수들의 시간 복잡도는 다음과 같다.
| 연산             | 시간 복잡도 | 설명                                                                                                                                   |
| ---------------- | ----------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| len(a)           | O(1)        | 요소의 총 개수 return                                                                                                                  |
| a[i]             | O(1)        | 인덱스 i의 요소 return                                                                                                                 |
| a[i:j]           | O(k)        | i부터 j까지 슬라이스한 k개의 요소를 가진 리스트 return                                                                                 |
| target in a      | O(n)        | target 요소가 a안에 존재하는 지 여부를 return (Boolean)                                                                                |
| a.count(target)  | O(n)        | a 안에 target의 수를 return                                                                                                            |
| a.index(target)  | O(n)        | a 안에 target 요소의 인덱스를 return                                                                                                   |
| a.append(target) | O(1)        | 리스트 마지막에 target요소를 추가                                                                                                      |
| a.pop()          | O(1)        | 리스트 마지막 요소를 추출 = 스택 연산                                                                                                  |
| a.pop(0)         | O(n)        | 첫번째 요소를 추출 = 큐 연산, 이 경우 전체 복사가 필요하므로 O(n)이다. 큐 연산은 주로 리스트보다는 O(1)연산이 가능한 Deque를 권장한다. |
| del a[i]         | O(n)        | 리스트의 인덱스 i에 위치한 요소를 제거. i에 따라 실행 시간이 다름 최악의 경우 O(n)                                                     |
| a.sort()         | O(n log n)  | 팀소트를 사용하여 정렬 최선의 경우 O(n)                                                                                                |
| min(a), max(a)   | O(n)        | 최솟값, 최댓값 return 전체를 선형 탐색해야하므로 O(n)                                                                                  |
| a.reverse()      | O(n)        | 리스트를 뒤집는다                                                                                                                      |
| a.insert(i, j)   | O(1)        | 리스트의 index i에 j를 넣는다                                                                                                          |

## 딕셔너리

- 키/값 구조로 이루어진 자료구조.
- 내부적으로 해시 테이블로 구현되어 있다.
- 파이썬 3.7 이후부터는 입력 순서가 보장되지만, 3.6 이하는 `collections.OrderedDict()` 라는 별도 자료형이 제공된다.
- 또한 조회 시 항상 default 값을 생성해 키 오류를 방지하는 `collections.defaultdict()`
- 요소의 값을 키로 하고 개수를 값 형태로 만들어 카운팅해주는 `collections.Counter()` 등이 있다.
- `dict()` 또는 `중괄호{}`로 선언한다.

딕셔너리의 주요 연산 함수들의 시간 복잡도는 다음과 같다.
| 연산           | 시간 복잡도 | 설명                                                    |
| -------------- | ----------- | ------------------------------------------------------- |
| len(a)         | O(1)        | 요소의 총 개수 return                                   |
| a[key]         | O(1)        | 키를 조회하여 값을 return return                        |
| a[key] = value | O(1)        | 값 삽입                                                 |
| key in a       | O(n)        | 딕셔너리 안에 key가 존재하는 지 여부를 return (Boolean) |

## 딕셔너리 모듈

위에서 말한 defaultdict, Counter, OrderedDict에 대해서 알아보자.

### defaultdict

- 존재하지 않는 키를 조회할 경우 default 값을 기준으로 해당 키에 대한 value를 생성해준다.

``` python
import collections

a = collections.defaultdict(int)
a['C'] += 1
print(a)

# >> defaultdict(<class 'int'>, {'C': 1})
```

### Counter 객체

Counter 객체는 아이템에 대한 개수를 계산해 딕셔너리로 return 한다.

``` python
import collections

a = [1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3]

counter = collections.Counter(a)

print(counter)
# >> Counter({3: 6, 1: 3, 2: 3})

common = counter.most_common(1) # 가장 빈도 수가 높은 key value 쌍 return
print(common)
# >> [(3, 6)]
```

# 6장 문자열 조작

## 팰린드롬

`팰린드롬`이란 앞뒤가 똑같은 단어나 문장을 말한다.
파이썬으로 모두 소문자인 문자열이 팰린드롬인지 판단하는 코드는 다음과 같다.

``` python
def is_palindrome(s: list) -> bool:
    while len(s) > 1:
        if s.pop(0) != s.pop():
            return False
    return True


s = input()

strs = []

for char in s:
    if char.isalnum():
        strs.append(char.lower())

print(is_palindrome(strs))
```

해당 문제는 리스트로도 충분히 풀 수 있지만, 데크(Deque)를 명시적으로 선언하면 좀 더 속도를 높일 수 있다.
**리스트의 pop()은 O(n)인 데 반해, deque의 popleft()는 O(1)이기 때문이다.**
위 코드에서 list를 deque로 변경한 코드는 다음과 같다.

``` python
import collections


def is_palindrome(s: collections.deque) -> bool:
    while len(s) > 1:
        if s.popleft() != s.pop():
            return False
    return True


s = input()

strs = collections.deque()

for char in s:
    if char.isalnum():
        strs.append(char.lower())

print(is_palindrome(strs))
```

파이썬의 슬라이싱을 이용하면 이는 내부적으로 c로 구현되어있기 때문에 속도를 좀 더 높일 수 있다. 코드 또한 매우 간결해진다.

``` python

def is_palindrome(s: str) -> bool:
  s = s.lower()

  # 불필요한 문자를 필터링
  s = re.sub('[^a-z0-9]', '', s)

  return s == s[::-1]


```

## 가장 긴 팰린드롬 부분 문자열

- 컴퓨터과학의 오랜 문제 중에 `최장 공통 부문 문자열(Longest Common Substring)`이라는 문제가 있다.
- 다이나믹 프로그래밍을 풀 수 있는 전형적인 문제이지만, 다이나믹 프로그래밍을 이용한 풀이는 직관적이지 않고, 예상과 달리 실행 속도가 늦다.
- 그래서 좀 더 성능이 좋은 투 포인터가 중앙을 중심으로 확장하는 형태의 풀이를 정리한다.
- 팰린드롬의 길이가 짝수(2 ~)일수도 홀수(3 ~)일 수도 있기때문에 크기가 2, 3으로 이루어진 투 포인터를 이용한다.
- 다음 문제는 [리트코드 5번 문제](https://leetcode.com/problems/longest-palindromic-substring/)이다.

``` python
def longest_palindrome(s: str) -> str:
    def expand(left: int, right: int): # (1)
        while (left >= 0 and right < len(s) and s[left] == s[right]): # (2)
            left -= 1
            right += 1
        return s[left + 1:right] # (3)

    if len(s) < 2 or s == s[::-1]: # (4)
        return s

    result = ''

    for i in range(0, len(s) - 1): 
        result = max(result, 
            expand(i, i + 1), # (5)
            expand(i, i + 2), # (6)
            key=len)          # (7)

    return result
```

- (1) 포인터의 범위를 넓히기 위한 함수이다.
- (2) left, right가 탐색 가능한 범위를 초과하지 않고, 서로 같은 값을 가지는지 확인(팰린드롬인지 검사)하면서 포인터의 범위를 넓혀간다.
- (3) 파이썬의 특징 중 문자열이 `s = "abc"`일때 `s[1]`은 `"b"`가 나오지만, `s[0:1]`은 n-1까지 가져오기 때문에 `"a"`가 나온다. 이를 주의하면서 코드를 이해해보자.
- (4) 파이썬의 슬라이싱 속도는 매우 빠르므로, 이와 같은 필터링 코드를 추가하면 전체적인 풀이 속도 향상에 도움이 된다.
- (5) 짝수 크기의 포인터
- (6) 홀수(3이상) 크기의 포인터
- (7) key는 len함수로 비교한다. max()는 각 매개변수를 비교해서 가장 큰 값을 리턴한다.

## 문자열 뒤집기

- `list.reverse()`
- 슬라이싱 `[::-1]`
  - 슬라이싱은 기존 배열을 수정하지 않는 다는 것에 주의!
  - 기존 배열을 수정하고 싶다면 다음과 같이 하면 된다. `s[:] = s[::-1]`

## 정렬

- 람다식과 `sort()`를 이용하면 **리스트 자료형**(가변)을 여러 조건을 가지고 정렬할 수 있다.
- sort()는 기존 배열을 수정한다. 리턴값은 None이다.
- 다음 예시는 letters에 들어있는 문자열[1:]을 키로 먼저 정렬하고 동일할 경우, 문자열[0]을 기준으로 정렬한다.
즉 앞에서 부터 우선순위 조건이다.

``` python
letters.sort(key=lambda x: (x.split()[1:], x.split()[0]))
```

- `sorted()`를 이용해서 정렬할 수도 있다.
  - 문자열도 정렬이 가능하며, 정렬된 리스트를 반환한다.
  - 이후 `join()` 등으로 여러 활용이 가능하다.
  - 또한 `sort()`와 동일하게 key를 이용해 우선 순위 정렬도 가능하다.

  ``` python
  >>> b = 'fwead'
  >>> sorted(b)
  ['a', 'd', 'e', 'f', 'w']
  >>> ''.join(sorted(b))
  'adefw'
  ```

## 파이썬이 사용하는 정렬 알고리즘 : 팀소트(Timsort)

- 파이썬은 정렬 알고리즘으로 팀소트 알고리즘을 사용한다.
- 정렬 알고리즘 중에서 가장 인기 있는 알고리즘은 폰 노이만이 설계한 `병합 정렬(Merge Sort)`이다.
- 대부분은 `퀵 정렬`이 더 빠르지만 데이터에 따라 편차가 큰 반면, 병합 정렬은 일정하게 O(n log n)의 안정적인 성능을 보이며, 무엇보다 안정 정렬이라는 점에서 많이 선호되는 편이다.
- `팀소트`는 팀 피터스가 파이썬을 위해 C로 구현한 알고리즘으로 `실제 데이터는 대부분 이미 정렬되어 있을 것이다`라고 가정하고 실제 데이터에서 고성능을 낼 수 있도록 설계한 알고리즘이며, 삽입 정렬과 병합 정렬을 휴리스틱하게 적절히 조합해 사용하는 정렬 알고리즘이다.
- 사실상 팀소트는 병합 정렬, 퀵 정렬을 제치고 현업에서 가장 널리 쓰이는 정렬 알고리즘이다.

## 애너그램

- `애너그램`이란  일종의 언어 유희로 문자를 재배열하여 다른 뜻을 가진 단어를 말한다.
  - ex) ate, eat
- 애너그램을 판단하는 건 생각보다 간단하다.
  - 해당 문자를 정렬 후 비교하여 동일하다면 이는 애너그램에 해당한다.
- 다음은 특정 문자열 배열을 애너그램 단위로 그룹핑하여 출력하는 예시이다.

``` python
import collections 

strs = ["eat", "tea", "tan", "ate", "nat", "bat"]

anagrams = collections.defaultdict(list) # (1) 

for word in strs:
  anagrams[''.join(sorted(word))].append(word) # (2)


print(anagrams.values()) # (3)
```

- (1) 기본값으로 list를 가지는 dict 선언
- (2) sorted는 문자배열을 리턴하므로 join()을 사용해서 문자열로 만들고, 해당 문자열을 key로하는 value list에 word를 append 한다.
- (3) values()로 키를 제외한 values만 가져온다.

## 유용한 함수들

### isalnum()

`영숫자(alphanumeric)` 여부를 판별하는 함수.

### lower()

모두 소문자로 변환

### re.sub()

- 정규식을 활용해서 replace 가능
- 전처리 작업에 유용하다.

``` python
re.sub('[^a-z0-9]', '', s) # 영문자 아닌 경우 replace
# 단어 문자가 아닌 경우 replace (,.!?;"') 등 r를 문자열 앞에 붙이면 raw 문자열이 되며, 이스케이프 문자가 적용되지 않고 인용 부호 안의 문자가 그대로 출력됨
re.sub(r'[^\w]', '', s) 
```

### isdigit()

숫자 여부를 판별

### split()

split()은 매개변수로 아무런 값을 입력해주지 않으면 공백을 기본으로 문자열을 나눈다.

### max()

- ```max(*args, key=None)```

- max는 각 args를 비교해서 가장 큰 값을 return한다.


### divmod()

``` python
>>> divmod(10, 3)
(3, 1)
```

- 10을 3으로 나눈 `몫`과 `나머지`로 구성된 tuple을 return 한다.

# 7장 배열

## 투 포인터

- **투 포인터 기법이란, 여러 방식이 있겠지만, 대게는 시작점과 끝점 또는 왼쪽 포인터와 오른쪽 포인터 두 지점을 기준으로 하는 문제 풀이 전략을 말한다**
- 일반적으로는 `배열이 정렬되어 있을 때 유용`하다
- 사실 투 포인터에 대해서 아직까지 명확하게 정의된 것은 없으며 알고리즘 풀이와 관련해 등장한 실전적인 풀이 기법이다.

## 최댓값과 최솟값

- 파이썬에서 최솟값과 최댓값을 선언하는 방법은 다음과 같다.
- 파이썬은 임의 정밀도(실수 크기 무제한)를 제공하기 때문에 큰 문제 없이 코딩 테스트의 모든 테스트 케이스를 통과할 수 있을 것이지만, 사실상 sys.maxsize로 선언하는 것도 의미가 없다고 한다.
- 대개 코딩 테스트에서는 최솟값, 최댓값을 제약 조건에 기술하기 때문에 이를 활용하자.

  ``` python
  # sys 
  max = sys.maxsize
  min = -sys.maxsize

  # float('inf')
  max = float('inf')
  min = float('-inf')
  ```

# 8장 연결 리스트

## 런너 기법

- 런너(Runner) 기법은 연결 리스트를 순회할 때 2개의 `포인터`를 동시에 사용하는 기법이다.
- 한 포인터가 다른 포인터보다 앞서에 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있다.
- 2개의 포인터는 각각 빠른 런너(Fast Runner), 느린 런너(Slow Runner)라고 부르는데, 보통 빠른 런너는 두 칸씩 이동하고, 느린 런너는 한 칸씩 이동하게 된다.
- 이 때, 빠른 런너가 연결 리스트의 끝에 도달하면, 느린 런너는 정확히 연결 리스트의 중간 지점을 기리키게 된다.
- 이 같은 방식으로 중간 위치를 찾아내면 해당 위치에서부터 값을 비교하거나 뒤집기를 시도하는 등 여러 활용도가 있다.
- 연결 리스트 문제에서 자주 쓰이는 기법이기도 하다.