# 개요

TEST 코드는 어떤 생각을 가지고 어떻게 작성하는 것이 올바른지 학습하기 위해서
패캠 The RED : 이규원의 현실 세상의 TDD : 안정감을 주는 코드 작성 방법 강의를 수강하며,
TDD에 대한 내용을 정리한다

- [개요](#개요)
  - [테스트 코드](#테스트-코드)
  - [테스트 우선 개발](#테스트-우선-개발)
  - [작업 환경 정리](#작업-환경-정리)
  - [테스트 주도 개발](#테스트-주도-개발)
  - [켄트 벡의 설계 규칙](#켄트-벡의-설계-규칙)
  - [기대 출력 피드백](#기대-출력-피드백)
  - [오버엔지니어링](#오버엔지니어링)
  - [핵심은 피드백](#핵심은-피드백)
  - [private method를 테스트해야만 하는가?](#private-method를-테스트해야만-하는가)
  - [TDD의 한계](#tdd의-한계)

## 테스트 코드

- 요구사항으로 도출된 가시적이고 구체적인 목표
- 자가검증 능력을 가짐
- 반복실행이 가능하며
- 운영 코드의 실제 클라이언트 중 하나가 됨

## 테스트 우선 개발

- 테스트를 먼저 작성하고 개발을 한다
- 명확하고 검증 가능한 목표를 설정한 후 목표를 달성
- 프로세스가 코딩에 앞선 목표 설정을 강요
- 프로그래머는 자신이 풀어야할 문제를 구체적으로 이해해야 함

-> 구조적으로 프로그래머가 해당 기능을 구체적으로 파악하게하는 효과

## 작업 환경 정리

- `생산성` : 정리된 환경과 어지렵혀진 환경에서의 작업 생산성 차이
- `지속성` : 작업 환경의 생산성이 일정 수준 미만으로 떨어지면 더 이상 그 환경에서 작업 진행 불가능

우리는 이를 `리팩터링`이라 부른다. 리팩터링에 대해서 알아보자

- `팩터링` : 의미를 유지하며 숫자나 대상을 더 작은 단위로 나눈다.
- `리팩터링` : 의미를 유지하며 코드베이스를 다시 정리

## 테스트 주도 개발

테스트 주도 개발 절차는 아래 과정을 반복한다.

`RED`(실패하는 테스트 추가) -> `GREEN`(테스트 통과, 최소한의 코딩) -> `REFACTOR`(구현 설계 개선, 테스트 통과 유지)

- `테스트 실패`
  - 구체적인 하나의 요구사항을 검증하는 하나의 테스트를 추가 
  - 추가된 테스트가 실패하는지 확인
  - 실패하는 것을 확인해야 테스트가 동작함을 믿을 수 있다.
  - 운영 코드 변경이 진행되지 않았기 때문에 실패했는지 확인해야 한다.
- `테스트 성공`
  - 추가된 테스트를 비롯해 모든 테스트가 성공하도록 운영 코드를 변경
  - 테스트 성공은 요구사항 만족을 의미
  - ***테스트 성공을 위한 최소한의 변경** -> 추가적인 코드를 작성한다는 건 테스트되지 않은 코드를 추가하는 행위
  - 테스트를 통과하는 코드를 빠르게 작성하는 것이 효율적
- `리팩터링`
  - 코드베이스 정리
  - 구현 설계 개선(가독성, 적응성, 성능)
  - ***모든 테스트 성공을 전제**

## 켄트 벡의 설계 규칙

- Passes the tests : 테스트 통과
- Reveals intention : 의도 노출(가독성)
- No duplication : 중복 제거
- Fewest elements : 가장 적은 요소(앞선 과정에 필요없는 코드는 제거)

https://martinfowler.com/bliki/BeckDesignRules.html

## 기대 출력 피드백

프로그래머는 피드백을 통해 프로그램을 발전시킨다.

- `사용자 피드백` : 사용자가 직접 코드를 사용한 후 경험한 버그나 불만을 제보
- `QA(Quality Assurance)` : 전문 인적 자원에 의한 인수 테스트
- `프로그래머 테스트` : 프로그래머가 직접 피드백 장치를 준비(테스트 코드 등)
- `도구 피드백` : 컴파일 오류, 정적 검사 등 프로그래머가 사용하는 도구가 제공하는 피드백

## 오버엔지니어링

- 프로그래머는 요구사항 명세에 **명확히 지정되지 않은 성능 달성이나 구현 설계 품질 개선에 빠져드는 경향**을 가짐
- 이런 목표는 그 자체로 나쁜 것이 아니지만 지나치면 더 중요한 목적, 기능 요구사항에 써야할 자원을 불필요하게 낭비하게 됨

- `테스트 주도 개발`은 가장 중요한 목표를 우선 달성하도록 유도하며, 오버엔지니어링에 빠졌음을 느낄 때 안심하고 다음으로 나아갈 수 있도록 **피드백을 제공**

## 핵심은 피드백

- 테스트 주도 개발의 핵심은 정해진 절차가 아니라 짧은 주기로 지속되는 **피드백**
- 피드백에 기반해 안정적을 지식과 코드를 늘려 나가는 것이 목적

## private method를 테스트해야만 하는가?

- [No](http://shoulditestprivatemethods.com/)
- 비공개 모듈의 작성과 사용은 공개 모듈의 구현 영역에 속함
- -> 비공개 모듈 테스트는 공개 모둘의 구현을 테스트하게 됨
- 테스트가 interface에 의존하는 것이 아니라 구현에 의존하게 됨 -> 강한 의존성(내용 결합)으로 치명적인 단점
- **private method 테스트 시 단점**
  - 테스트가 공개 모듈 구현에 의존
  - 정보 숨김 위배
  - SUT와 테스트 사이의 높은 결합

## TDD의 한계

- **은탄환**은 없다.. TDD 또한 만능은 아니다
- 모든 코드의 목표가 안정적이지 않으므로 요구사항이 지속적으로 변경될 수 있음
- 이런 불안정한 목표로 인해서 탐색적으로 목표를 찾아내는 환경에서는 테스트 작성을 어렵게 만듬
- `환경에 따른 의존성`
  - 테스트해야하는 코드의 의존성이 안정적이지 않은 경우 제어가 어려움
  단위 테스트는 결정적(deterministic)일수록 유용하다
  - 의존성 중 일부 동작이 매우 느리면 테스트 실행 비용 증가
  테스트는 실행 속도가 빠를 수록 좋다
  - 가정으로 인한 안정감 저하
  의존성의 단점을 보완할 테스트 대역 도입 시 **가정**이 발생하고 이는 실제 운영에서 에러가 발생할 수 있다는 불안감을 일으킴
- `낮은 코드 적응력`
  - 코드 적응력이 낮으면 단위 테스트하기 매우 어려움
  - 이미 코드 적응력이 낮은 코드 기반에 TDD를 적용하기는 어려움
  - 기존 코드의 적응력을 높이는 것도 어렵다
    - -> `설계 변경의 어려움`, `변경된 설계 검증 필요`
