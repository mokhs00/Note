# 알고리즘

- [알고리즘](#알고리즘)
  - [알고리즘이란?](#알고리즘이란)
  - [알고리즘 분석](#알고리즘-분석)
  - [시간 복잡도](#시간-복잡도)
  - [점근성능](#점근성능)
  - [점근성능의 표기법](#점근성능의-표기법)
  - [순환 알고리즘의 성능 (재귀 : recursion)](#순환-알고리즘의-성능-재귀--recursion)
  - [분할정복 방법](#분할정복-방법)
    - [이진 탐색](#이진-탐색)
    - [퀵 정렬](#퀵-정렬)
    - [합병 정렬](#합병-정렬)

## 알고리즘이란?

- 주어진 문제의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령을 순서적을 구성한 것

## 알고리즘 분석

알고리즘 분석의 기준은 다음과 같다

- 정확성 분석
  - 유효한 입력, 유한 시간 -> 정확한 결과 생성 여부
  - 다양한 수학적 기법을 사용해서 이론적인 증명이 필요
  - 현재 많이 알려진 알고리즘들은 이미 이론적으로 증명된 알고리즘임
- 효율성 분석
  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  - 메모리 양 -> `공간 복잡도`(space complexity)
  - 정적 공간 + 동적 공간
  - 수행 시간 -> `시간 복잡도`(time complexity)

## 시간 복잡도

- `시간 복잡도` : 알고리즘의 단위 연산의 수행 횟수의 합
- 입력 크기를 n이라고 하여 입력 크기 n에 대한 함수 f(n)으로 표현된다
- 입력 데이터의 상태에 종속적이며 상태에 따라 수행 시간이 다음과 같이 분류됨
  - 평균 수행 시간
  - 최선 수행 시간
  - `최악 수행 시간` -> 최악의 수행 시간을 시간 복잡도로 사용함
- 시간 복잡도에 영향을 미치는 요인
  - 입력 크기
    - 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
    - ex) 행렬의 크기, 리스트 원소의 수, 그래프의 정점의 수 등
  - 입력 데이터의 상태
    - 정렬 여부 등

## 점근성능

- `점근 성능` : 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
- n이 커질수록 상수 및 계수는 성능에 미치는 영향이 줄어든다
- 결국 다항식 함수에서 계수를 제외한 최고차항이 성능에 가장 중요한 영향이고 이를 점근성능으로 결정한다
- 그러므로 수행 시간의 정확한 값이 아닌 어림값이다 -> 그럼 왜 사용하는가?
- 수행 시간의 증가 추세를 파악하는데 용이함 -> 알고리즘의 우열 표현이 용이하기 때문에 사용

## 점근성능의 표기법

점근성능의 표기법에 대해서 알아보자

- `Big-oh 점근적 상한`
  - 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 이 때 모든 어떤 상수 c와 n0가 존재하여 모든 `n >= n0`에 대하여 `f(n) <= c * g(n)`이면 `f(n) = O(g(n))`이라고 표기한다
  - 즉 Big-oh는 상한을 측정하는 표기법이다
- `Big-omega 점근적 하한`
  - 점근적 상한의 반대 경우이다
  - `Ω(n)`으로 표기한다
- `Big-theta 점근적 상하한`
  - Big-oh(점근적 상항)와 Big-omega(점근적 하한) 를 동시에 표현하는 표기법이다
  - 위와 동일하게 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 어떤 양의 상수 c1, c2와 n0가 존재하며 모든 `n >= n0`에 대하여 `c * g(n) <= f(n) <= c2 * g(n)` 이면 `f(n) = 𝛉(g(n))` 이라고 표기한다
- 표기법을 계산하는 식들이 복잡하지만 보통 계수를 뺀 최고차항으로 표기한다
- 따라서 `루프의 반복 횟수`를 조사하여 시간복잡도를 표현하게 된다
- ex) n + 2 -> O(n), 이중 for문 -> O(n^2)

## 순환 알고리즘의 성능 (재귀 : recursion)

- 순환(recursion, 재귀) : 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
- 순환 알고리즘의 성능을 도출하기 위해서는 점화식을 도출해 점화식을 풀어서 점근성능을 표기해야한다

## 분할정복 방법

- 순환적(recursively)으로 문제를 푸는 하향식(top-down) 접근 방법
- 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고
- 이렇게 분할된 작은 문제들을 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식
- 분할된 작은 문제는 원래 문제와 동일(입력 크기만 작아짐)
- 분할된 작은 문제는 서로 독립적(순환적 분할 및 결과 통합 가능)
- `분할` -> `정복` -> `결합`의 순서로 풀이
- `분할` : 주어진 문제를 여러 개의 작은 문제로 분할
- `정복` : 작은 문제를 순환적으로 분할 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구함
- `결합` : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다(결합 단계가 없는 문제도 존재)
- 알고리즘 예시
  - 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제

### 이진 탐색

- 정렬된 상태의 입력 데이터에 대해서 효괴적인 탐색 방법
- ex) 오름차순으로 정렬되어 있는 경우
- 탐색을 반복할때마다 대상 원소의 개수가 1/2씩 감소
- 탐색 방법(오름차순으로 정렬된 입력 데이터를 가정)
  - 배열의 가운데 원소 `current`(`A[mid]`)와 탐색키 `x`를 비교
  - `x = current` -> 탐색 성공(인덱스 `mid`반환 후 종료)
  - `x < current` -> 재탐색(원래 크기의 1/2인 왼쪽 부분배열)
  - `x > current` -> 재탐색(원래 크기의 1/2인 오른쪽 부분배열)

다음은 js로 작성한 이진탐색 예시 코드이다

```js
// arr : 배열, n = 배열의 크기, x = 찾고자 하는 대상 요소
function BinarySearchIteration(arr[], n, x) {
  let left = 0;
  let right = n-1;
  while(left <= right){
    let mid = (left + right) / 2;

    if (x == arr[mid]) {
      return mid; // 탐색 성공
    } else if (x < arr[mid]) {
      right = mid - 1; // 왼쪽 부분배열
    } else {
      left = mid + 1; // 오른쪽 부분배열
    }
  }
  return -1; // 탐색 실패
}

function BinarySearch(arr[], left, right, x) {
  if(left > right) return -1;
  let mid = (left + right) / 2;
  if(x == arr[mid]) return mid;
  else if(x < arr[mid]) return BinarySearch(arr, left, mid - 1, x);
  else return BinarySearch(arr, mid + 1, right, x);
}
```

### 퀵 정렬

- 특정 원소(피벗)를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 변경되는 피벗 값의 위치를 반복적으로 찾아가면서 정렬하게 됨
- `피벗`(pivot) : 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
- 퀵 정렬의 최악의 수행시간은 피벗 기준으로 두 부분 배열이 불규칙하게 나눠지는 경우(ex) 0 : n-1) `O(n^2)`이고
- 최선의 경우 피벗을 기준으로 두 부분배열이 동일한 크기로 나눠지는 경우 `O(nlogn)`이다
- 평균 수행시간은 `O(nlogn)`이 된다

``` c
QuickSort(arr[], n){
  if(n > 1){
    pivot = Partition(arr[0..n-1], n); // 두 부분배열로 분할
    QuickSort(arr[0..pivot-1], pivot); // 왼쪽 부분배열
    QuickSort(arr[pivot+1..n-1], n - pivot - 1); // 오른쪽 부분 배열
  }
}

// 분할 함수
int Partition(arr[], n){
  left = 1; right = n-1;
  while(left < right){ // 피벗 arr[0]

    // 피벗보다 큰 값의 위치를 찾음
    while(left < n && arr[left] < arr[0]) left++;
    // 피벗보다 작은 값의 위치를 찾음
    while(right > 0 && arr[right] >= arr[0]) right--;

    if(left < right) 교환(arr[left] <=> arr[right])
    else 교환(arr[0] <=> arr[right]) // 피벗 값과 교환

  }
  return right

}
```

### 합병 정렬

- 합병 정렬은 분할 정복 방식으로 다음과 같은 과정을 거친다
- (분할) 배열을 동일한 크기의 두 개의 부분배열로 분할
- (정복) 각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분배열을 정렬한다
- (결합) 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다

``` c
MergeSort(A[], n)
{
  if (n > 1) {
    Mid = [n / 2];
    B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid);
    C[0..n-Mid-1] = MergeSort(A[Mid..n-1], Mid, n-Mid);

    // 합병
    A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid)
  }
  return A;
}

Merge(B[], C[], n, m)
{
  A[];
  i = j = k = 0;
  while (i < n  && j < m) {
    if(B[i] <= C[j])
      A[k++] = B[i++];
    else
      A[k++] = C[j++];
  }
  for(; i<n; i++) A[k++] = B[i];
  for(; j<m; j++) A[k++] = C[j];
  return A[0..n+m-1];
}
```