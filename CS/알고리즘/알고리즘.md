# 알고리즘

- [알고리즘](#알고리즘)
  - [알고리즘이란?](#알고리즘이란)
  - [알고리즘 분석](#알고리즘-분석)
  - [시간 복잡도](#시간-복잡도)
  - [점근성능](#점근성능)
  - [점근성능의 표기법](#점근성능의-표기법)
  - [순환 알고리즘의 성능 (재귀 : recursion)](#순환-알고리즘의-성능-재귀--recursion)
  - [분할정복 방법](#분할정복-방법)
    - [이진 탐색](#이진-탐색)
    - [퀵 정렬](#퀵-정렬)
    - [합병 정렬](#합병-정렬)
  - [동적 프로그래밍(Dynamic programing)](#동적-프로그래밍dynamic-programing)
    - [문자열 편집 거리 문제(edit distance)](#문자열-편집-거리-문제edit-distance)
    - [최단 경로 알고리즘(플로이드 와샬)](#최단-경로-알고리즘플로이드-와샬)
    - [저울 문제](#저울-문제)
  - [힙(heap)](#힙heap)

## 알고리즘이란?

- 주어진 문제의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 유한개의 일련의 명령을 순서적을 구성한 것

## 알고리즘 분석

알고리즘 분석의 기준은 다음과 같다

- 정확성 분석
  - 유효한 입력, 유한 시간 -> 정확한 결과 생성 여부
  - 다양한 수학적 기법을 사용해서 이론적인 증명이 필요
  - 현재 많이 알려진 알고리즘들은 이미 이론적으로 증명된 알고리즘임
- 효율성 분석
  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  - 메모리 양 -> `공간 복잡도`(space complexity)
  - 정적 공간 + 동적 공간
  - 수행 시간 -> `시간 복잡도`(time complexity)

## 시간 복잡도

- `시간 복잡도` : 알고리즘의 단위 연산의 수행 횟수의 합
- 입력 크기를 n이라고 하여 입력 크기 n에 대한 함수 f(n)으로 표현된다
- 입력 데이터의 상태에 종속적이며 상태에 따라 수행 시간이 다음과 같이 분류됨
  - 평균 수행 시간
  - 최선 수행 시간
  - `최악 수행 시간` -> 최악의 수행 시간을 시간 복잡도로 사용함
- 시간 복잡도에 영향을 미치는 요인
  - 입력 크기
    - 입력으로 제공되는 데이터의 크기, 문제가 해결하려는 대상이 되는 개체의 개수
    - ex) 행렬의 크기, 리스트 원소의 수, 그래프의 정점의 수 등
  - 입력 데이터의 상태
    - 정렬 여부 등

## 점근성능

- `점근 성능` : 입력 크기 n이 무한대로 커짐에 따라 결정되는 성능
- n이 커질수록 상수 및 계수는 성능에 미치는 영향이 줄어든다
- 결국 다항식 함수에서 계수를 제외한 최고차항이 성능에 가장 중요한 영향이고 이를 점근성능으로 결정한다
- 그러므로 수행 시간의 정확한 값이 아닌 어림값이다 -> 그럼 왜 사용하는가?
- 수행 시간의 증가 추세를 파악하는데 용이함 -> 알고리즘의 우열 표현이 용이하기 때문에 사용

## 점근성능의 표기법

점근성능의 표기법에 대해서 알아보자

- `Big-oh 점근적 상한`
  - 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 이 때 모든 어떤 상수 c와 n0가 존재하여 모든 `n >= n0`에 대하여 `f(n) <= c * g(n)`이면 `f(n) = O(g(n))`이라고 표기한다
  - 즉 Big-oh는 상한을 측정하는 표기법이다
- `Big-omega 점근적 하한`
  - 점근적 상한의 반대 경우이다
  - `Ω(n)`으로 표기한다
- `Big-theta 점근적 상하한`
  - Big-oh(점근적 상항)와 Big-omega(점근적 하한) 를 동시에 표현하는 표기법이다
  - 위와 동일하게 함수 f와 g를 각각 양의 정수를 갖는 함수라 하자
  - 어떤 양의 상수 c1, c2와 n0가 존재하며 모든 `n >= n0`에 대하여 `c * g(n) <= f(n) <= c2 * g(n)` 이면 `f(n) = 𝛉(g(n))` 이라고 표기한다
- 표기법을 계산하는 식들이 복잡하지만 보통 계수를 뺀 최고차항으로 표기한다
- 따라서 `루프의 반복 횟수`를 조사하여 시간복잡도를 표현하게 된다
- ex) n + 2 -> O(n), 이중 for문 -> O(n^2)

## 순환 알고리즘의 성능 (재귀 : recursion)

- 순환(recursion, 재귀) : 알고리즘의 수행 과정에서 자기 자신의 알고리즘을 다시 수행하는 형태
- 순환 알고리즘의 성능을 도출하기 위해서는 점화식을 도출해 점화식을 풀어서 점근성능을 표기해야한다

## 분할정복 방법

- 순환적(recursively)으로 문제를 푸는 하향식(top-down) 접근 방법
- 주어진 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고
- 이렇게 분할된 작은 문제들을 각각 해결한 후 이 해들을 결합해서 원래 문제의 해를 구하는 방식
- 분할된 작은 문제는 원래 문제와 동일(입력 크기만 작아짐)
- 분할된 작은 문제는 서로 독립적(순환적 분할 및 결과 통합 가능)
- `분할` -> `정복` -> `결합`의 순서로 풀이
- `분할` : 주어진 문제를 여러 개의 작은 문제로 분할
- `정복` : 작은 문제를 순환적으로 분할 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구함
- `결합` : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다(결합 단계가 없는 문제도 존재)
- 알고리즘 예시
  - 이진 탐색, 합병 정렬, 퀵 정렬, 선택 문제

### 이진 탐색

- 정렬된 상태의 입력 데이터에 대해서 효괴적인 탐색 방법
- ex) 오름차순으로 정렬되어 있는 경우
- 탐색을 반복할때마다 대상 원소의 개수가 1/2씩 감소
- 탐색 방법(오름차순으로 정렬된 입력 데이터를 가정)
  - 배열의 가운데 원소 `current`(`A[mid]`)와 탐색키 `x`를 비교
  - `x = current` -> 탐색 성공(인덱스 `mid`반환 후 종료)
  - `x < current` -> 재탐색(원래 크기의 1/2인 왼쪽 부분배열)
  - `x > current` -> 재탐색(원래 크기의 1/2인 오른쪽 부분배열)

다음은 js로 작성한 이진탐색 예시 코드이다

```js
// arr : 배열, n = 배열의 크기, x = 찾고자 하는 대상 요소
function BinarySearchIteration(arr[], n, x) {
  let left = 0;
  let right = n-1;
  while(left <= right){
    let mid = (left + right) / 2;

    if (x == arr[mid]) {
      return mid; // 탐색 성공
    } else if (x < arr[mid]) {
      right = mid - 1; // 왼쪽 부분배열
    } else {
      left = mid + 1; // 오른쪽 부분배열
    }
  }
  return -1; // 탐색 실패
}

function BinarySearch(arr[], left, right, x) {
  if(left > right) return -1;
  let mid = (left + right) / 2;
  if(x == arr[mid]) return mid;
  else if(x < arr[mid]) return BinarySearch(arr, left, mid - 1, x);
  else return BinarySearch(arr, mid + 1, right, x);
}
```

### 퀵 정렬

- 특정 원소(피벗)를 기준으로 주어진 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 퀵 정렬을 순환적으로 적용하는 방식
- 변경되는 피벗 값의 위치를 반복적으로 찾아가면서 정렬하게 됨
- `피벗`(pivot) : 주어진 배열을 두 부분배열로 분할할 때 기준이 되는 특정 원소
- 퀵 정렬의 최악의 수행시간은 피벗 기준으로 두 부분 배열이 불규칙하게 나눠지는 경우(ex) 0 : n-1) `O(n^2)`이고
- 최선의 경우 피벗을 기준으로 두 부분배열이 동일한 크기로 나눠지는 경우 `O(nlogn)`이다
- 평균 수행시간은 `O(nlogn)`이 된다

``` c
QuickSort(arr[], n){
  if(n > 1){
    pivot = Partition(arr[0..n-1], n); // 두 부분배열로 분할
    QuickSort(arr[0..pivot-1], pivot); // 왼쪽 부분배열
    QuickSort(arr[pivot+1..n-1], n - pivot - 1); // 오른쪽 부분 배열
  }
}

// 분할 함수
int Partition(arr[], n){
  left = 1; right = n-1;
  while(left < right){ // 피벗 arr[0]

    // 피벗보다 큰 값의 위치를 찾음
    while(left < n && arr[left] < arr[0]) left++;
    // 피벗보다 작은 값의 위치를 찾음
    while(right > 0 && arr[right] >= arr[0]) right--;

    if(left < right) 교환(arr[left] <=> arr[right])
    else 교환(arr[0] <=> arr[right]) // 피벗 값과 교환

  }
  return right

}
```

### 합병 정렬

- 합병 정렬은 분할 정복 방식으로 다음과 같은 과정을 거친다
- (분할) 배열을 동일한 크기의 두 개의 부분배열로 분할
- (정복) 각각의 부분배열에 대해서 합병 정렬을 순환적으로 적용하여 두 부분배열을 정렬한다
- (결합) 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다

``` c
MergeSort(A[], n)
{
  if (n > 1) {
    Mid = [n / 2];
    B[0..Mid-1] = MergeSort(A[0..Mid-1], Mid);
    C[0..n-Mid-1] = MergeSort(A[Mid..n-1], Mid, n-Mid);

    // 합병
    A[0..n-1] = Merge(B[0..Mid-1], C[0..n-Mid-1], Mid, n-Mid)
  }
  return A;
}

Merge(B[], C[], n, m)
{
  A[];
  i = j = k = 0;
  while (i < n  && j < m) {
    if(B[i] <= C[j])
      A[k++] = B[i++];
    else
      A[k++] = C[j++];
  }
  for(; i<n; i++) A[k++] = B[i];
  for(; j<m; j++) A[k++] = C[j];
  return A[0..n+m-1];
}
```

## 동적 프로그래밍(Dynamic programing)

- 문제의 크기가 작은 소문제에 대한 해를 저장해 놓고, 이를 이용해 크기가 보다 큰 문제의 해를 점진적으로 만들어가는 `상향식(bottom-up)` 접근 방법
- 각각의 소문제는 원래의 문제와 동일하지만 입력 크기만 줄어듦
- 입력 크기가 아주 작은 단순한 문제가 되면 쉽게 해를 구할 수 있고, 이런 소문제의 해는 다시 사용될 수 잇도록 테이블에 저장(메모)함
- 해당 소문제의 해가 필요할 때마다 테이블에 메모해둔 데이터를 조회하여 사용
- **동적 프로그래밍(DP)을 적용하려면?**
  - 최적성의 원리를 반드시 만족해야 함 
  - `최적성의 원리` : 주어진 문제에 대한 최적해는 주어진 문제의 소문제에 대한 최적해로 구성된다
- **동적 프로그래밍 방법의 적용 과정**
  - 최적성의 원리 성립 여부 확인
  - 주어진 문제에 대해서 최적해를 제공하는 `점화식` 도출
  - 가장 작은 소문제부터 점화식의 해를 구해 테이블에 메모
  - 테이블에 저장된 소문제의 해를 이용해 점차적으로 큰 상위 문제의 해를 도출

### 문자열 편집 거리 문제(edit distance)

- 두 문자열 사이의 근접성 또는 유사성을 판단하여 편집에 필요한 연산 비용을 구하는 알고리즘
- 문자열 X를 Y로 변환하는데 필요한 최소 비용
  - 특정 위치에 새 문자를 삽입하는 비용
  - 특정 위치의 문자를 삭제하는 비용
  - 특정 위치의 문자를 변경하는 비용
- 위 3가지 경우를 기반으로 점화식을 세우고 2차원 배열(map)을 이용해 풀이
- map[n][m]를 만들기 위해서 (n+1)(m+1)개의 연산이 필요
- map[n][m]에 도달하기 위해서 하는 연산의 수는 ixj -> 따라서 O(ij)

### 최단 경로 알고리즘(플로이드 와샬)

- 모든 정점에서 다른 모든 정점으로 가는 최단거리를 구하는 알고리즘
- 가중치의 합이 음수인 사이클이 존재하지 않아야 함
- 정점 x -> 정점 y로 가는 중에 정점 z를 거쳐서 가는 경우와 거쳐가지 않는 경우의 비용을 비교하여 최소값을 기록

``` c
FloydWarshall(V, E)
[
  D[][] // 그래프를 인접 행렬로 초기화
  for(k=1~V까지)
    for(i=1~V까지)
      for(j=1부터~V까지)
        if(D[i][j] > D[i][k] + D[k][j])
          D[i][j] = D[i][k] + D[k][j]

  return D[][];
]
```

### 저울 문제

- 양팔 저울에서 다양한 무게가 존재하는 n개의 추가 있고 무게 M인 물체를 양팔 저울에 달 수 있는지 판별하는 문제
- 추의 무게와 무게를 측정하고자 하는 물체의 무게는 모두 정수여야 함
- 아래 상황을 고려하여 점화식을 세워서 각 상황을 기록하여 저울에 달 수 있는지 판별한다
  - 선택된 추에 n번 추가 포함되지 않는다면
  - 선택된 추에 n번 추가 포함된다면

## 힙(heap)

- 완전 이진 트리의 일종
- 여러 개의 값들 중에서 최댓값 혹은 최솟값을 빠르게 찾아낼 수 있도록 설계됨
- 가장 큰 값이 루트 노드에 존재하고 가장 작은 값이 단말 노드에 존재하는 구조
- 삽입, 삭제 시에도 해당 구조를 유지하도록 로직을 구성함
