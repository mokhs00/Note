# 운영체제

- [운영체제](#운영체제)
  - [운영체제의 역할](#운영체제의-역할)
  - [CPU의 동작 모드](#cpu의-동작-모드)
  - [시스템 호출](#시스템-호출)
  - [커널](#커널)
    - [일체형 커널(monolithic kernel)](#일체형-커널monolithic-kernel)
    - [마이크로 커널](#마이크로-커널)
  - [운영체제의 구성](#운영체제의-구성)
    - [프로세스 관리자](#프로세스-관리자)
    - [메모리 관리자](#메모리-관리자)
    - [장치 관리자](#장치-관리자)
    - [파일 관리자](#파일-관리자)
  - [운영체제의 유형](#운영체제의-유형)
    - [일괄처리(batch processing) 운영체제](#일괄처리batch-processing-운영체제)
    - [대화형(interactive) 운영체제](#대화형interactive-운영체제)
    - [실시간(real-time) 운영체제](#실시간real-time-운영체제)
    - [하이브리드(hyrid) 운영체제](#하이브리드hyrid-운영체제)
  - [프로세스(process)](#프로세스process)
  - [프로세스 운영자의 역할](#프로세스-운영자의-역할)
  - [프로세스의 상태](#프로세스의-상태)
    - [프로세스 5-상태 모델](#프로세스-5-상태-모델)
  - [프로세스 제어 블록(PCB)](#프로세스-제어-블록pcb)
  - [프로세스 생성과 종료](#프로세스-생성과-종료)
    - [프로세스 생성](#프로세스-생성)
    - [프로세스 생성 시스템 호출](#프로세스-생성-시스템-호출)
    - [생성되는 프로세스의 자원](#생성되는-프로세스의-자원)
    - [프로세스 종료](#프로세스-종료)
    - [프로세스 종료 시스템 호출](#프로세스-종료-시스템-호출)
  - [프로세스 간의 관계](#프로세스-간의-관계)
  - [전통적인 프로세스](#전통적인-프로세스)
  - [쓰레드(Thread)](#쓰레드thread)
  - [다중 쓰레드의 장점](#다중-쓰레드의-장점)
  - [스케줄링](#스케줄링)
    - [상위단계 스케줄링](#상위단계-스케줄링)
    - [하위단계 스케줄링](#하위단계-스케줄링)
    - [중간단계 스케줄링](#중간단계-스케줄링)
  - [스케줄링 정책](#스케줄링-정책)
    - [선점(Preemptive) 스케줄링 정책](#선점preemptive-스케줄링-정책)
    - [비선점(Nonpreemptive) 스케줄링 정책](#비선점nonpreemptive-스케줄링-정책)

## 운영체제의 역할

- 컴퓨터 시스템의 운영
  - 컴퓨터 시스템의 자원을 제어 및 관리
  - 응용프로그램들의 실행을 도와주는 소프트웨어
- 사용자 지원
  - 사용자의 명령을 해석하여 실행
  - 사용자와 하드웨어 사이의 매개체 역할수행

## CPU의 동작 모드

![./운영체제/컴퓨터%20구성.png](./운영체제/컴퓨터%20구성.png)

- 슈퍼바이저 모드(커널 모드)
  - 운영체제의 커널이 동작되는 모드
  - 하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 가능
- 보호 모드(사용자 모드)
  - 응용 프로그램이 동작되는 모드
  - 하드웨어를 직접 제어할 수 있는 CPU 명령어 사용 불가능

## 시스템 호출

- 응용 프로그램이 운영체제에게 서비스를 요청하는 메커니즘
- 시스템 호출하게되면 다음과 같은 과정이 일어난다
- `시스템 호출` -> `보호모드에서 슈퍼바이저 모드로 변경` -> `커널 동작` -> `하드웨어 제어`

## 커널

- 운영체제의 핵심요소
- 응용프로그램과 하드웨어 수준의 처리 사이의 가교 역할
- 대표적인 구성 방식 : 일체형 커널, 마이크로 커널

### 일체형 커널(monolithic kernel)

- 운영체제의 모든 서비스가 커널 내에 포함됨
- 일체형 커널을 사용하는 보통 운영체제를 안정적으로 만들기 때문에 시스템 장애가 발생할 확률은 거의 없고 서버용으로 자원을 효율적으로 활용하기 위해 사용한다
- `장점`
  - 커널 내부 요소들이 서로 효율적으로 상호작용을 할 수 있음
- `단점`
  - 한 요소에 있는 오류로 인해 시스템 전체에 장애가 발생할 수 있음
- ex) UNIX, Linux

### 마이크로 커널

- 운영체제의 대부분의 요소들을 커널 외부로 분리
- 커널 내에는 메모리 관리, 멀티태스킹, 프로세스 간 통신(IPC) 등 최소한의 요소들만 남김
- `장점`
  - 새로운 서비스를 추가하여 운영체제를 확장하기 쉬움
  - 유지보수가 용이하며 안정성이 우수함
- `단점`
  - 커널 외부 요소들 사이는 IPC를 통해야만 하므로 성능 저하가 발생함

## 운영체제의 구성

운영체제는 다음과 같이 구성된다

- 프로세스 관리자
- 메모리 관리자
- 파일 관리자
- 장치 관리자

### 프로세스 관리자

- 프로세스를 생성, 삭제, CPU 할당을 위한 `스케쥴` 결정
- `프로세스`란 실행중인 프로그램을 의미하며, 프로그램 파일이 실행되어 메모리 상에 올라오면 프로세스로 취급한다
- 여기서 프로세스가 실행되기 위해서는 CPU를 통해서 명령을 처리해야하는데 서로 동시에 CPU를 사용할 수 없으므로 `스케줄링`을 이용하게 되고 이런 역할을 하는 것이 `프로세스 관리자`이다.

### 메모리 관리자

- 메모리(주기억장치) 공간에 대한 요구의 유효성 체크
- 메모리 할당 및 회수
- 메모리 공간 보호
- 각 응용프로그램이 사용하는 메모리 공간이 충돌되지 않도록 관리하는 역할

### 장치 관리자

- 컴퓨터 시스템의 모든 장치를 관리
- 시스템의 장치를 할당, 작동 시작, 반환
- 장치란 키보드, 프린터, 네트워크 장치 등을 의미한다

### 파일 관리자

- 컴퓨터 시스템의 모든 파일을 관리
- 파일의 접근 제한 관리
- 파일을 열어 자원을 할당하거나 파일을 닫아 자원을 회수

## 운영체제의 유형

- 응답시간의 속도, 데이터 입력의 방식에 따라 분류
  - 일괄처리 운영체제
  - 대화형 운영체제
  - 실시간 운영체제
  - 하이브리드 운영체제

### 일괄처리(batch processing) 운영체제

- 작업을 모아서 처리
- 사용자와 상호작용 없이 순차적으로 실행
- 효율성 평가 : 처리량, 반환시간
- 처리량 : 주어진 시간 안에 처리된 작업의 수
- 반환시간 : 작업의 생성 시점부터 종료 시점까지의 소요시간

### 대화형(interactive) 운영체제

- 시분할 방식을 이용하기에 시분할 운영체제라고도 함
- 일괄처리 운영체제보다 빠르지만 실시간 운영체제보다는 느린 응답시간
- 이용자에게 즉각적인 피드백을 제공
- 응답시간 : 요청한 시점부터 반응이 시작되는 시점까지의 소요시간

### 실시간(real-time) 운영체제

- 가장 빠른 응답시간
- 처리의 결과가 현재의 결정에 영향을 주는 환경에서 사용
- 우주선 비행 시스템, 미사일 제어, 증권거래 관리 시스템, 은행 입출금 시스템 등에 사용

### 하이브리드(hyrid) 운영체제

- 일괄처리 운영체제와 대화형 운영체제의 결합
- 이용자는 터미널을 통해 접속하고 빠른 응답시간을 얻음
- 대화형 작업이 많지 않을 경우 백그라운드에서 배치 프로그램 실행
- 현재 사용되고 있는 대부분의 대형 컴퓨터 시스템은 하이브리드 운영체제

## 프로세스(process)

- 실행중인 프로그램
  - 프로그램 : 동작을 하지 않는 정적-수동적 개체
  - 프로세스 : 동작을 하는 능동적인 개체
- 운영체제로부터 자원을 할당받아 동작
  - 자원 : CPU, 메모리, 입출력장치, 파일 등
  - 동작 : CPU가 프로세스의 명령을 실행
- 사용자 및 시스템 프로세스 존재

## 프로세스 운영자의 역할

- 프로세스를 생성 및 삭제
- 프로세스 실행(CPU 할당)을 위한 스케쥴 결정
- 프로세스의 상태를 관리하며 상태 전이를 관리
  
## 프로세스의 상태

프로세스의 상태란 무엇인지 알아보자

### 프로세스 5-상태 모델

![./운영체제/5-state-process-model.png](./운영체제/5-state-process-model.png)

- 생성 : 처음 작업이 시스템에 주어진 상태
- 준비 : 실행 준비가 되어 CPU 할당을 기다리는 상태
- 실행 : 프로세스가 처리되는 상태
- 대기 : 프로세스가 특정 자원을 할당받을 때까지 또는 I/O 작업이 끝날 때까지 작업이 보류되는 상태
- 종료 : 모든 처리가 완료되어 사용자에게 반환되는 상태

## 프로세스 제어 블록(PCB)

- 프로세스 제어 블록(Process Control Block, PCB)
  - 프로세스의 관리를 위한 목적
  - 프로세스의 정보를 보관
  - 각 프로세스마다 존재
  - 프로세스가 진행함에 따라 내용 변경

## 프로세스 생성과 종료

### 프로세스 생성

- 프로세스의 이름(번호, PID) 결정
- 준비 큐에 삽입
- 초기 우선순위 부여
- 프로세스 제어 블록(PCB) 생성 등

### 프로세스 생성 시스템 호출

프로세스 생성은 [시스템 호출](#시스템-호출)을 이용한다

- 하나의 프로세스가 프로세스 생성 시스템 호출을 통해 새로운 프로세스를 생성
- ex) fork()
- 호출하는 프로세스 : 부모 프로세스
- 생성되는 프로세스 : 자식 프로세스

### 생성되는 프로세스의 자원

- 운영체제로부터 직접 얻는 경우
- 부모 프로세스 자원의 일부를 얻는 경우
- 자식 프로세스의 자원은 부모 프로세스의 자원으로 제한
  - 과도한 자식 프로세스 생성에 따른 시스템 과부하 방지

### 프로세스 종료

- 프로세스의 마지막 명령이 실행을 마치는 경우
- 프로세스 종료 시스템 호출(예: exit())을 통하는 경우
- 프로세스 종료 후 부모 프로세스에게 실행 결과를 되돌려 줌

### 프로세스 종료 시스템 호출

- 부모에 의해서만 호출
- 자식 프로세스가 할당된 자원의 사용을 초과할 때 혹은 더 이상 필요하지 않을 때

## 프로세스 간의 관계

프로세스는 프로세스 간의 관계에 따라 다음과 같이 분류될 수 있다.

- `독립적 프로세스`
  - 다른 프로세스의 영향을 주고받지 않음
  - 다른 프로세스와 프로세스 상태 공유 X
  - 결정적, 재생 가능 : 같은 입력 시 같은 출력이 발생
  - 다른 프로세스와 무관하게 중단 및 재시작 가능
  - 데이터를 다른 프로세스와 공유하지 않음

- `유기적 프로세스`
  - 다른 프로세스와 영향을 주고받음
  - 다른 프로세스와 프로세스 상태 공유 O
  - 비결정적, 재생 불가능 : 같은 입력 시 같은 출력이 발생하지 않음
  - 데이터를 다른 프로세스와 공유함

## 전통적인 프로세스

- 처리의 기본 단위
- 자원 소유의 단위(하나의 주소공간) 및 디스패칭(dispatch)의 단위(하나의 제어흐름)
- 단일 프로세스 내에서 동시처리 불가능으로 인해서 `쓰레드`가 제안됨

## 쓰레드(Thread)

- 프로세스 내에서의 다중처리를 위해 제안된 개념
- 하나의 프로세스 내에는 하나 이상의 쓰레드가 존재
- 하나의 쓰레드 내에서는 하나의 실행점만 존재(디스패칭의 단위)
- 실행에 필요한 최소한의 정보만을 가지며, 자신이 속해 있는 프로세스의 실행환경을 공유

## 다중 쓰레드의 장점

- 멀티 CPU 혹은 멀티코어 시스템에서는 병렬처리 가능
- 처리 속도 별로 쓰레드가 나눠진 경우 효율적인 처리 가능

## 스케줄링

- 스케줄링의 목표
  - 공정성 : 모든 프로세스가 적정 수준에서 CPU 작업을 할 수 있게 함
  - 균형 : 시스템의 자원들이 충분히 활용될 수 있게 함
- 스케줄링 단계
  - 상위단계 스케줄링
  - 하위단계 스케줄링
  - 중간단계 스케줄링

### 상위단계 스케줄링

- 시스템에 들어오는 작업들을 선택하여 프로세스를 생성한 후 프로세스 준비 큐에 전달
- 선택 기준 : 시스템 자원을 효율적으로 이용할 수 있도록 하는 것
- 입출력(I/O) 중식 작업과 연산 중심 작업을 균형있게 선택

### 하위단계 스케줄링

- CPU가 가용상태에 어느 프로세스에게 배당할지 결정
- CPU를 배당받은 프로세스는 실행상태가 되어 처리됨
- 수행 주체 : 디스패처(dispatcher)

### 중간단계 스케줄링

- 프로세스를 일시적으로 메모리에서 제거하여 중지시키거나 다시 활성화시킴
- 시스템에 대한 단기적인 부하를 조절

## 스케줄링 정책

스케줄링 정책은 다음과 같이 분류된다

- 선점 스케줄링 정책
- 비선점 스케줄링 정책

### 선점(Preemptive) 스케줄링 정책

- 진행 중인 프로세스에 인터럽트를 걸고 다른 프로세스에 CPU를 할당하는 스케줄링 전략
- 높은 우선순위의 프로세스를 긴급하게 처리하는 경우에 유용
- 대화식 시분할 시스템에서 빠른 응답시간을 유지하는데 유용
- CPU를 선점하기 때문에 발생하는 문맥 교환에 따른 오버헤드 발생
- `문맥` : CPU의 모든 레지스터와 기타 운영체제에 따라 요구되는 프로세스의 상태
- `문맥 교환` : CPU의 현재 실행하고 있는 프로세스의 문맥을 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업

### 비선점(Nonpreemptive) 스케줄링 정책

- 프로세스가 CPU를 할당받아 실행이 시작되면 작업 자체가 I/O 인터럽트를 걸거나 작업을 종료할 때까지 실행단계에 있게 됨
- 모든 프로세스가 공정하게 순서에 따라 실행됨 -> 응답시간 예측 가능
- 짧은 프로세스가 긴 프로세스를 기다리게 될 수 있음
