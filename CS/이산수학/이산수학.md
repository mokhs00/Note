# 이산수학

- [이산수학](#이산수학)
  - [이산수학이란](#이산수학이란)
  - [추상화(abstraction)](#추상화abstraction)
  - [알고리즘(algorithm)](#알고리즘algorithm)
  - [알고리즘의 표현 방법](#알고리즘의-표현-방법)
  - [컴퓨터로 계산 가능한 3가지 제어구조(control structure)](#컴퓨터로-계산-가능한-3가지-제어구조control-structure)
  - [명제(Proposition)](#명제proposition)
  - [합성 명제(compound proposition)](#합성-명제compound-proposition)
  - [조건 명제(conditional proposition, ->)](#조건-명제conditional-proposition--)
  - [쌍조건 명제(condition proposition, <->)](#쌍조건-명제condition-proposition--)
  - [논리적 동치(logical equivalence, ≡)](#논리적-동치logical-equivalence-)
  - [역, 이, 대우](#역-이-대우)
  - [논리적 동치법칙](#논리적-동치법칙)
  - [논리(logic)](#논리logic)
    - [명제함수 (propositional function)](#명제함수-propositional-function)
    - [한정화(quantificaiton)](#한정화quantificaiton)
  - [추론(inference)](#추론inference)
    - [유효추론](#유효추론)
  - [공리(axiom)](#공리axiom)
  - [증명 (proof)](#증명-proof)
  - [정리(theorem)](#정리theorem)
  - [직접증명법(direct proof)](#직접증명법direct-proof)
  - [관계의 성질](#관계의-성질)
    - [동치관계(equivalence relation)](#동치관계equivalence-relation)
    - [동치류(equivalence class)](#동치류equivalence-class)
  - [함수(function)](#함수function)
    - [함수의 종류](#함수의-종류)
  - [그래프](#그래프)
    - [그래프 표현](#그래프-표현)
  - [트리](#트리)
    - [트리의 종류](#트리의-종류)

## 이산수학이란

- 수학은 다루는 값에 따라 다음과 같이 분류될 수 있다
  - 연속수학 : 연속적인 값
  - 이산수학 : 연속적이지 않은 값 ex) 디지털 0, 1
- 따라서 이산수학은 이산적인 수학 구조(연속적이지 않은 값)에 대해 다루는 수학이라고 볼 수 있다

## 추상화(abstraction)

- 문제와 관련된 핵심내용만 남기고 관련 없는 내용을 제거하여 문제를 단순화시키는 과정

## 알고리즘(algorithm)

- 어떠한 문제를 해결하기 위한 여러 동작들의 유한한 모임

## 알고리즘의 표현 방법

- 프로그래밍 언어
  - 컴퓨터 작동을 위한 동작을 시멜하게 제시
  - 알고리즘의 핵심요소가 잘 드러나지 않음
  - 중요하지 않은 부차적인 표현에 신경써야 함
  - 통일된 언어가 존재하지 않음
- 순서도
  - 장점 : 알고리즘의 작동방식을 도식화함
  - 단점 : 내용이 복잡하거나 프로그램의 크기가 클 경우에 표현하기 어려움
- 의사코드
  - 모호한 부분은 프로그래밍 언어의 문법을 채용하여 명확하게 기술
  - 구체적으로 표현할 필요가 없는 부분은 자연어를 통해 설명식으로 기술
  - 알고리즘의 작동방식을 설명하는 용도로만 사용
  - C언어를 기반으로 하는 의사코드 사용

## 컴퓨터로 계산 가능한 3가지 제어구조(control structure)

- 순차(Sequence)
- 선택(Selection) - if, switch
- 반복(Iteration) - for, while

## 명제(Proposition)

- 참과 거짓을 구별할 수 있는 문장이나 수학적 식을 말함
- 명제의 진리값(truth value)
  - 참 (True), T : 명제가 타당한 경우
  - 거짓 (False), F : 명제가 타당하지 않은 경우
- 종류
  - 합성명제
  - 조건명제, 쌍조건명제
  - 항진명제(항상 참), 모순명제(항상 거짓)

## 합성 명제(compound proposition)

- 하나 이상의 명제와 논리연산자 그리고 괄호로 이루어진 명제
- `논리합`(disjunction; or, ∨)
  - p ∨ q
- `논리곱`(conjunction; and, ∧)
  - p ∧ q
- `부정`(negation: ~, ￢)
  - ~p
- `배타적 논리합`(exclusive or; xor, ⊕)
  - 위 기본 연산으로 표현할 수 있음
  - p, q기 서로 다른 값이여야 참
  - p ⊕ q ≡ (p ∧ ~q) ∨ (~p ∧ q)

## 조건 명제(conditional proposition, ->)

- 명제 p와 q가 있을 때, 명제 p가 조건의 역할을 수행하고 명제 q가 결론의 역할을 수행하는 경우
- p -> q
- p는 q의 충분조건
- q는 p의 필요조건

## 쌍조건 명제(condition proposition, <->)

- 명제 p와 q가 있을 때, 명제 p와 q가 조건의 역할과 결론의 역할을 동시에 수행하는 경우

## 논리적 동치(logical equivalence, ≡)

- 두 명제 p와 q가 논리적으로 동등하면 논리적 동치라고 하고, p ≡ q로 표시한다
- 논리적으로 동등하다는 건 두 명제가 항상 동일한 진리값을 가진다는 의미이다
- `p <-> q,` `p <=> q`, `p ≡ q` 등 여러 표기법이 있음

## 역, 이, 대우

- 조건명제 `p -> q`의 경우
  - 역(converse) : `q -> p`
  - 이(inverse) : `~p -> ~q`
  - 대우(contrapositive) : `~q -> ~p`

## 논리적 동치법칙

- 교환법칙 (commutation law)
  - `p V q <=> q V p`
  - `p ^ q <=> q ^ p`
  - `p <-> q <=> q <-> p`
- 결합법칙 (associative law)
  - `(p V q) V r <=> p V (q V r)`
  - `(p ^ q) ^ r <=> p ^ (q ^ r)`
- 분배법칙 (distributive law)
  - `p V (p ^ r) <=> (p V q) ^ (p V r)`
  - `p ^ (q V r) <=> (p ^ q) V (p ^ r)`
- 항등법칙 (identiy law)
  - `p V F <=> p`
  - `p ^ T <=> p`
- 지배법칙 (domination law)
  - `p V T <=> T`
  - `p ^ F <=> F`
  - `p V (~p) <=> T`
  - `p ^ (~p) <=> F`
- 이중 부정 법칙(double negation law)
  - `~(~p) <=> p`
- 멱등법칙(idempotent law)
  - `p V p <=> p`
  - `p ^ p <=> p`
- 드 모르간 법칙(de Morgan's law)
  - `~(p V q) <=> (~p) ^ (~q)`
  - `~(p ^ q) <=> (~p) V (~q)`
- 흡수법칙(absorption law)
  - `p V (p ^ q) <=> p`
  - `p ^ (p V q) <=> p`
- 함축법칙(implication law)
  - `p -> q <=> ~p V q`
- 대우법칙
  - `p -> q <=> ~q -> ~p`

## 논리(logic)

- 명제 논리(proposition logic)
- 술어 논리(predicate logic)
  - 명제 함수

### 명제함수 (propositional function)

- 변수의 값에 의해 함수의 진리값이 결정되는 문장이나 식
- 변수의 명세
  - 변수의 값을 적시
  - 변수의 범위를 제시(한정화:∀, ∃)

### 한정화(quantificaiton)

- 전체한정자(universal quantifier, ∀)
  - 전체한정자는 "모든" 또는 "임의의"를 의미한다
  - 명제함수 ∀xP(x)와 같이 사용되었을 경우에는 정의역의 모든 "임의의" x에 대해서 P(x)가 참(T)임을 의미한다
- 존재한정자(existential quantifier, ∃)
  - 존재한정자는 "존재한다"를 의미하며, 명제함수 ∃xP(x)와 같이 사용되었을 때는 정의역의 어떤 x에 대해서 P(x)가 참(T)임을 의미한다

## 추론(inference)

- 참으로 알려진 명제를 기초로 하여 다른 명제를 유도해 내는 과정
- 결론의 근거를 제공하는 알려진 명제를 전제(premise)라고 한다
- 새로 유도된 명제는 결론(conclusion)

### 유효추론

- 유효추론은 전제를 참(T)이라고 가정했을 때 결론이 항상 참(T)이 되는 추론
- 기본적인 추론규칙은 논리적 동치(항진명제)를 이용한다

## 공리(axiom)

- 별도의 증명 없이 참으로 이용되는 명제
- 어떤 다른 명제들을 증명하기 위해 전제로 사용되는 가장 기본적인 가정의 역할을 하기도 함

## 증명 (proof)

- 특정한 공리들을 가정하고, 그 가정하에 제안된 명제가 참임을 입증하는 과정

## 정리(theorem)

- 공리로부터 증명된 명제를 정리라고 함
- 보조정리 (lemma)
  - 정리를 증명하는 과정 중에 사용되는 증명된 명제
- 따름정리 (corollary)
  - 정리로부터 쉽게 도출되는 부가적인 명제
- 증명 방법
  - `직접 증명법` : 공리, 정의 그리고 정리를 논리적으로 직접 연결하여 증명
  - `수학적 귀납법` : 자연수 n에 대한 명제의 성질을 증명하는데 유용한 증명 방법. 기본단계, 귀납가정, 귀납단계를 이용
  - `간접 증명법` : 증명해야 할 명제를 증명하기 쉬운 형태로 변형하여 증명하는 방법 (대우 증명법, 모순 증명법, 반례 증명법, 존재 증명법, ...)
  - `그 외` : 전수 증명법, 조합적 증명법, 컴퓨터 이용 증명법, ...

## 직접증명법(direct proof)

- 주로, 공리와 정의, 그리고 이미 증명된 정리를 논리적으로 직접 연결해 증명하는 형식
- 연역법이라고도 함
- 연역법 (deduction) : 이미 증명된 하나 또는 둘 이상의 명제를 전제로 하여 새로운 명제를 결론으로 이끌어내는 것
- 명제를 변형하지 않고 증명

## 관계의 성질

- 반사적(reflexive) : a->a => reflexion(거울을 보는 것과 유사)
- 대칭적(symmetric) : a->b, b->a => 대칭적
- 추이적(transitive) : a->b, b->c => a->c 성립

### 동치관계(equivalence relation)

- R : 집합 A에서 관계
- R이 `반사적`, `대칭적`, `추이적`이라면, R을 **동치관계**라고 부름

### 동치류(equivalence class)

- 관계 R이 집합 A에서의 동치관계일 때, A의 임의의 원소 a에 대해서 a와 관계를 맺고 있는 집합 x를 **동치류**라고 부름

ex) 집합 A = {0,1,2}, 관계 R = {(0,0), (1,1), (1,2), (2,1), (2,2)} 일 때
서로 다른 동치류를 구하는 방법은 다음과 같다

- [0] = {0}
- [1] = {1, 2}
- [2] = {1, 2}

-> 따라서 서로 다른 동치류는 {{0}, {1, 2}}

## 함수(function)

- 집합 X, Y가 있을 때 X에서 Y로의 관계를 **함수**(function)이라고 정의
- X의 임의의 원소 x에 대해서는 관계를 맺는 Y의 임의의 원소 y가 하나만 존재해야함
- 집합 X -> 집합 Y의 관계에서 다음과 같이 각 집합, 요소들을 정의할 수 있음
  - 집합 X : f 의 `정의역`(domain), Y : f의 `공역`
  - Y의 원소 y : x의 `상`(image), X의 원소 x: y의 `역상`
  - f(X) : f의 `치역` => Y의 원소들

### 함수의 종류

- `전사함수`(surjective function)
  - onto function(Y의 모든 원소가 치역일 때)
- `단사함수`(injectivce function)
  - one-to-one function(f(x1)=y1, f(x2)=y1이라면 x1=x2 여야 함)
- `전단사함수`(bijective function)
  - 전사함수와 단사함수의 특징을 모두 만족하는 경우
- `역함수`(inverse function)
  - f가 전단사함수인 경우 f의 역관계를 f의 역함수라고 함
- `합성함수`(composition function)
  - (g∘f) = g(f(x))
- `계승함수`(factorial)
  - n : 음이 아닌 정수일 때 n! ex) 5!
- `바닥함수`(floor function)
  - 실수 x에 대해서 x보다 작거나 같으면서 가장 큰 정수를 구하는 함수 `max()`
  - ⌊x⌋ 로 표기
- `천장함수`(ceiling function)
  - 실수 x에 대해서 x보다 크거나 같으면서 가장 작은 정수를 구하는 함수 `min()`
  - ⌈x⌉ 로 표기
- `나머지 함수`(modulo function)
  - `mod()`
  - n mod m 으로 표기

## 그래프

- 주요 용어
  - `정점`(=`꼭지점` vertex or node or station): ㅈ
  - `간선`(=`변` edge or link or line)
  - 변은 두 꼭지점을 연결함 => 변에 의해 `발생`(incident)되었다고 표현
  - 연결된 두 꼭지점은 서로 `인접`(adjacent)한다고 함
  - `병렬 변`(parallel edge) : 두 꼭지점을 연결하는 변이 복수 개 있을 때
  - `루프`(loop) : 동일한 꼭지점을 연결하는 변
  - `고립된 꼭지점`(isolated vertex) : 어떠한 변도 연결되지 않은 꼭지점
  - `동형`(isomorphic) : 꼭지점과 변의 이름만 제외하고는 모두 동일한 그래프를 서로 동형이라고 함
- 그래프의 종류
  - `방향 그래프`, `무향 그래프` : 간선의 반향 여부에 따라 구분
  - `단순 그래프` : 루프와 병렬 변을 가지지 않는 무향 그래프
  - `다중 그래프` : 병렬 변을 가지는 무향 그래프
  - `부분 그래프`(subgraph) : 그래프의 부분 집합인 그래프를 지칭
  - `신장 부분 그래프`(spanning subgraph) : 정점은 모두 가지고 있고 간선이 부분 집합인 그래프를 지칭
  - `정점의 차수`(degree) : 연결된 간선의 수
  - `그래프의 총 차수`(total degree) : 모든 정점의 차수의 합
  - `워크`(walk) : 한 정점에서 한 정점으로 가는 경로의 꼭지점과 변들을 순서대로 나열한 것
    - 워크 W의 변들이 모두 서로 다르면 `트레일`(trail)이라고 함
    - 트레일 W의 꼭지점이 모두 다르면 W를 `경로`(path)라고 함
  - `완전 그래프` : 임의의 두 꼭지점을 연결하는 변이 항상 존재하는 그래프
    - 완전 그래프의 모든 꼭지점의 차수는 n - 1
  - `이분 그래프`(bipratite graph) : V는 연결성분이 V1과 V2로 분할되어 있고 모든 변들이 V1의 꼭지점과 V2의 꼭지점을 인접시키는 경우
  - `완전 이분 그래프` : 이분 그래프인데 완전 그래프처럼 V1의 한 꼭지점이 V2의 한 꼭지점으로의 간선을 모두 가지고 있음
  - `정규 그래프`(regular graph)
    - 그래프 G의 모든 꼭지점들이 동일한 수의 인접한 꼭지점을 갖는 경우
    - 차수가 k라면 `k-정규 그래프` 라고도 칭함

### 그래프 표현

- 발생 행렬(incident matrix)
  - 간선, 꼭지졈을 각각 행, 열로 하여 간선을 기준으로 발생 여부를 행렬로 표현
- 인접 행렬(adjacency matrix)
  - 꼭지점을 행과 열로 하여 꼭지점 사이의 인접 관계를 행렬로 표현
- 인접 리스트(adjacency list)
  - 인접 행렬을 연결리스트로 표현

## 트리

- 사이클이 없는 단순 연결 그래프
- 용어 정리
  - 노드의 차수 : 자식 노드의 수
  - 트리의 차수 : 노드의 차수 중 가장 큰 값
  - 노드의 레벨(level) : 루투에서 해당 노드까지 경로의 길이
  - 트리의 높이(height), 깊이(depth) : 노드의 레벨 중 가장 큰 값
  - 리프 노드 : 차수가 0인 노드

### 트리의 종류

- `이진 트리`(binary tree)
  - 공집합이거나 모든 노드가 최대 2개의 서브트리를 갖는 루트 노드인 트리
  - 이진 트리의 최대 노드의 개수 = 2^h+1 -1 (h: height)
- `완전 이진 트리`(complete binary tree)
  - 모든 노드가 채워져 있고 왼쪽부터 차례로 채워진 이진트리
- `포화 이진 트리`(full binary tree)
  - 최대 깊이까지 모든 노드가 채워진 이진 트리
- `이진 탐색 트리`(binary search tree)
  - 이진 트리에서 모든 노드가 탐색을 위한 키(key)값을 가지고 있고 각 키가 다음의 속성을 만족하는 이진트리
    - 임의의 노드 N에 대해서 왼쪽 서브트리의 키값들은 N의 키값 K보다 작아야함
    - 임의의 노드 N에 대해서 오른쪽 서브트리의 키값들은 N의 키값 K보다 커야함
- `신장 트리`(spanning tree)
  - 그래프 G의 모든 꼭지점을 포함하는 트리
- `최소 신장 트리`(minimum spanning tree)
  - 모든 변의 가중치의 총 합이 가장 작은 신장 트리
