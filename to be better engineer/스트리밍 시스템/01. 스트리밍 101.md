# 1장 스트리밍 101

[스트리밍 101](https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/)이라는 글이 있는데 이 내용을 기반으로 스트리밍에 대한 맛보기 섹

## 오늘날 빅데이터 분야에서 스트리밍 데이터 처리가 주목받고 있다

주목받는 이유는 다음과 같음

- 현대 비즈니스에서 대규모의 무한 데이터셋(unbounded dataset)이 점점 더 보편화되고 있으며, 이런 데이터는 끝없이 입력되는 데이터를 다룰 수 있도록 설계된 시스템을 사용하면 쉽게 처리할 수 있음
- 데이터가 도착하는 시점에 처리될 수 있으면 시스템의 작업 부하가 고르게 분산돼 좀 더 일관되고 예측 가능한 형태로 시스템 자원을 소비할 수 있음

- 스트리밍에 대한 업계의 관심이 증가했음에도 스트리밍 시스템은 배치방식에 비해 긴 시간 미성숙한 상태였다. 하지만 최근에 이 대세가 반대로 바뀜

## 이번 섹션의 내용 구성은 이렇게

- **용어 정의(terminology)**
  - 스트리밍과 관련된 용어 살펴보기
- **스트리밍의 기능(capability)적 이야기**
  - 종종 회자되는 스트리밍 시스템의 단점에 대한 이야기
  - 데이터 처리 시스템을 구축하려는 사람들이 사용자의 요구를 만족시키기 위해 도입해야 하는 생각의 틀을 제안
- **스트리밍에서의 시간 영역(time domain)**
  - 데이터 처리와 관련된 두 가지 시간 영역을 소개(이벤트 시간, 처리 시간)
  - 이들이 어떻게 연관돼 있는지 보고, 두 시간 영역으로 생기는 어려움에 대한 이야기

## 용어 정리

- **스트리밍 시스템**
  - 무한 데이터셋을 염두에 두고 설계된 데이터 처리 엔진의 유형
- 데이터 유형
  - **기수(cardinality), 구성(constitution)을 기준으로 나뉨**
  - **기수(=크기)를 기준으로 나누면**
    - **유한 데이터(bounded data)**
    - **무한 데이터(unbounded data)**
  - **구성을 기준으로 나누면 (물리적 표현)**
    - **테이블(table)**: 특정 시점의 데이터셋에 대한 뷰 SQL에서 보는 테이블과 같음
    - **스트림(stream)**: 시간에 따라 변화하는 데이터셋의 요소 단위 뷰
    - 이 책의 이후 내용에서 테이블과 스트림 사이의 관계에 대해서 깊게 알아본다고 함!

## 스트리밍 시스템이 배치 시스템을 이기려면?

우리는 스트리밍 시스템과 유사한 기능을 사용하기 위해 배치 시스템을 주기적으로 돌리는 환경을 주로 사용한다.
이는 과거부터 내려온 선택들이고 이제는 스트리밍 시스템이 성숙하여 보편화될 수 있는 환경이 되었다.
그렇다면 스트리밍 시스템이 배치 시스템을 이기기 위해서 필요한 것들은 무엇일까?

- **정확성(correctness)**
  - 스트리밍 시스템이 배치와 동등해지기 위해 필요한 조건.
  - 핵심은 일관성을 제공할 수 있는 스토리지(consistent storage)로 귀결됨
  - 스트리밍 시스템에서는 시간이 지남에 따라 영구 상태를 유지할 수 있는 체크포인트 방법이 필요
  - 또한 이 스토리지는 장애 상황에서도 일관성 유지가 필수
    - 스파크 스트리밍이 등장하며 일관성 지원이 가능함을 보여줌
  - 강한 일관성은 `정확히 한 번 처리`(exactly-once processing) 방식을 지원하기 위해서 반드시 필요하`정확히 한 번 처리` 는 정확성을 제공하기 위해서 필요 (=여러번 처리될 수도 있음)
  - 그리고 정확성은 최소한 배치 시스템의 능력 이상을 가지고자 하는 시스템이 갖추어야하는 필수 요소
  - 결론적으로 정확성이 중요한 상황이라면 강한 일관성을 제공되는 스트리밍 시스템을 사용해라!
    - e.g. 결제에서 사용한다고 하면 정확히 1번만 결제되어야함
- **시간 판단 도구(tools for reasoning about time)**
  - 스트리밍 시스템은 다양한 이벤트 시간 왜곡이 발생하는 상황에서 무한 비순서 데이터(unbounded unordered data)를 처리할 때 반드시 필요(=여러가지 이유로 실제 이벤트가 발생한 것보다 한참 뒤에 이벤트가 발행될 수 있음)
  - 오늘날 점점 더 많은 데이터가 무한 비순서 데이터의 특성을 보이며 기존 배치 시스템은 이런 특성으로 인한 어려움을 해결할 수 있는 도구가 부족

## 이벤트 시간 vs 처리 시간

- 이벤트 시간(event time)
  - 이벤트가 실제 발생한 시간
- 처리 시간(processing itme)
  - 이벤트가 처리 시스템에서 관측된 시간

이벤트 시간이 모든 경우에 중요한 것은 아니나 시간에 따른 사용자 행동의 특성을 분석하거나 결제 관련 서비스나 이상 징후 감지 등과 같은 대부분의 경우에 이벤트 시간은 중요

이상적인 상황이라면 어떤 사건이 발생한 죽시 처리될 것이므로, **이벤트 시간과 처리 시간은 항상 동일해야함**
그러나 현실은 그렇게 이상적이지 않으며 두 시간 사이의 시간 왜곡에는 입력 소스, 실행 엔진, 하드웨어 등 다양한 요소가 영향을 주게됨

**그래서 실제 시스템에서 이벤트 시간과 처리 시간이 변화하는 모습을 그림으로 표현하면 아래 이미지의 붉은 색 선이 됨**

![event-time-process-time](https://user-images.githubusercontent.com/72328687/210140567-5f144c50-5247-43e6-bd36-013f3cb47efe.png)

- 기본적으로 무한 데이터셋의 무한함이라는 특성을 다루기 위해 윈도우(window)라는 단위로 데이터를 잘라서 다룰 수 있다.
- 그리고 이런 기능들은 보통 무한데이터셋을 다루기 위해서 설계된 시스템에 포함됨

사실 위 내용을 보더라도 무한 데이터는 순서가 보장되지 않고 가변적인 왜곡이 발생할 수 있으므로 정확성면에서 이슈가 많다.

처리 시간을 기준으로 윈도우를 나눈다거나 이벤트 시간으로 윈도우를 나눈다고 하더라도 정확성에 문제가 있는 것은 피할 수 없다.

따라서 이 책에서는 무한한 데이터를 완결성을 갖는 유한한 묶음으로 처리하려는 시도보다는 복잡한 데이터셋이 갖는 불확실성을 다룰 수 있도록 도구를 설계해야하는 것을 제안한다

## 데이터 처리 패턴

배치/스트리밍 두 형태의 엔진을 고려하면서, 유한/무한 데이터 유형을 살펴보자

### 유한 데이터

![bounded-data](https://user-images.githubusercontent.com/72328687/210140666-041c3217-6dc8-423b-b446-891673ea3d8c.png)

유한데이터는 간단한 개념이라 우리에게 익숙하다

이 이미지는 맵리듀스를 예시로 들었는데
왼쪽의 비정형 데이터를 오른쪽과 같이 구조화된 데이터로 정리하여 더 큰 가치를 지니도록 하는 것이 핵심이다

그렇다면 무한 데이터는 어떻게 처리할까?
마이크로배치 혹은 스트리밍 시스템은 어떻게 무한 데이터를 처리하는지 알아보자

### 무한 데이터 \w 배치

배치 엔진은 무한 데이터를 염두에 두고 설계되지 않았지만 배치 시스템이 처음 고안된 이후로 무한 데이터셋 처리에도 쓰이고 있다.

여기서는 무한 데이터를 배치 처리에 적합한 유한 데이터셋의 집합으로 분할하는 것이 중요하다

### 고정 윈도우

![fixed-window](https://user-images.githubusercontent.com/72328687/210140710-d650c913-98c0-49c4-9934-4dc93912a463.png)

고정 윈도우. 말 그대로 고정된 윈도우로 무한 데이터를 유한 데이터셋의 집합으로 나누어 처리하는 방식이다

**현실적으로 대부분의 시스템에는 여전히 해결해야 하는 데이터 입력이 완결됐음을 알리는 완결성(completeness)의 문제 사례들을 좀 살펴보자**

대부분 완결성이 지켜져야하는 데이터가 고정 윈도우로 정한 범위 안에 포함되지 않아 발생하는 사례들이다.

- 이벤트를 전송하는 과정에서 네트워크 파티션으로 인해 일부가 지연되는 경우 어떻게 처리할 것인지
- 이벤트를 전체적으로 수집하고 이를 처리하기 전 공통 위치로 전송해야 하는 경우 어떻게 처리할 것인지
- 이벤트가 모바일 장치에서 발생하다면 어떻게 할 것인지(지연 등등)

결론적으로 이를 해결하기 위한 방법은 다시 배치를 돌리는 것인데, 모든 이벤트 수집을 확인할 때까지 처리를 지연하거나, 데이터가 늦게 도착하면 소속될 윈도우에 대해 전체 배치를 재실행하는 등의 방법으로 이런 문제를 완화할 수 있다

### 세션

세션을 활용하면 좀 더 정교한 윈도우 처리를 할 수 있다.

세션은 보통 세션의 활동 기간으로 정의되며, 일정 크기의 세션의 비활동 간격이 따라오면 끝나는 것으로 볼 수 있다

다음은 고전적인 배치 엔진에서 임시 방편의 고정 윈도우를 통해 무한 데이터를 세션으로 처리하는 모습이다.
무한 데이터셋은 유한한 고정 크기의 윈도우로 미리 수집된 다음 배치 엔진의 연속 실행을 통해 동적인 세션으로 분할된다.

![session-window](https://user-images.githubusercontent.com/72328687/210140720-e7625498-a88b-4fa2-bd12-c42d4a601c05.png)

대신 이 경우 다른 윈도우에서 같은 세션을 다루고 있다면, 세션을 묶어주기 위해 로직을 추가하는 복잡도가 증가하게 된다. 따라서 트레이드오프가 중요한데, 어느쪽이든 고전적인 배치 엔진을 사용해 세션을 계산하는 것은 바람직하지 않고 더 좋은 방법은 스트리밍 방식으로 세션을 구축하는 것이다

## 무한 데이터 \w 스트리밍

스트리밍 시스템은 무한 데이터 처리에 쓰이는 배치 방식이 임시방편적인 특성을 갖는 것과 다르게 태생부터 무한 데이터를 처리하기 위해 제작되었다.

스트리밍 시스템이 다루는 데이터는 무한 데이터일 뿐만 아니라 다음과 같은 특성도 갖는다

- **이벤트 시간 기준으로 심하게 뒤섞여 있는 데이터**
  - 이를 이벤트 시간을 기준으로 처리하려면 파이프라인에서 시간 기반의 셔플을 수행해야 함
- **데이터가 모두 도착했다고 확신할 수 없는 데이터**
  - 다양한 형태의 이벤트 시간 왜곡이 발생해 상수 시간 범위 안에 주어진 이벤트 시간 X의 대부분의 데이터를 봤다고 확신할 수 없

이와 같은 데이터를 다룰 때 활용할 수 있는 접근법이 몇가지 있는데 이를 하나씩 알아보자

- **시간 무시(time-agnostic)**
- **근사(approximation)**
- **처리 시간 윈도우(processing time window)**
- **이벤트 시간 윈도우(event time window)**

### 시간 무시(time-agnostic)

시간 무시 처리는 시간이 본질적으로 무관한 경우, 즉 데이터 처리의 모둔 결정을 데이터만 보면서 할 수 있을 때 사용한다.

모든 결정은 데이터가 도착하면서 이루어지기에 스트리밍 시스템은 단순히 데이터를 전달하는 목적으로 사용되게 된다. 따라서 모든 스트리밍 시스템은 시간 무시 처리를 바로 지원한다고 볼 수 있다.

그리고 배치 시스템 역시 무한 데이터를 임의의 유한 데이터셋으로 나누어 독립적으로 처리할 수 있기 때문에 무한 데이터의 시간 무시 처리에 적합하다.

### 필터링

시간 무시 처리의 가장 기본적인 형태는 필터링이다.

단순하게 특정 도메인에서 유래하지 않은 모든 트래픽은 무시한다고 해보자. 이런 경우 도착한 데이터를 보고 도메인이 속하는지 확인하고 그렇지 않으면 삭제한다.

이런 식이 작업은 항상 데이터가 단일 요소(e.g. 도메인)에만 의존하기 때문에 데이터 소스가 무한하고 정렬돼 있지 않으며 가변적인 이벤트 시간 왜곡이 있다는 사실과 무관해진다.

![filtering](https://user-images.githubusercontent.com/72328687/210140737-721fd64e-90d1-41cf-a994-183dd258ca4f.png)

### 내부 조인

시간 무시 처리의 다른 예시로 내부 조인은 단순하게 2개의 무한 데이터 소스를 조인할 때 조인의 결과만 중요하다면 시간적인 요소를 고려할 필요가 없다.

아래 이미지는 무한데이터에서 한 쌍의 데이터를 조인하는 모습이다. 첫 번재 데이터 발견 시에 이 데이터를 버퍼링해두고 두 번째 데이터가 도착하면 조인된 결과를 생성한다.

이런 경우에 쌍이 안 맞는 경우가 있을 수 있으므로 해당 데이터를 만료시키기 위한 시간적 정책 혹은 GC(Garbage Collection)가 필요할 수 있다.

![inner-join](https://user-images.githubusercontent.com/72328687/210140738-d56afbd4-cfc5-4c5d-9bdf-8a9954082695.png)

### 근사 알고리즘

말 그대로 무한데이터를 입력받아 우리가 얻고자 하는 결과와 비슷한 결과를 생성하는 알고리즘
e.g. Top-N, 스트리밍 K-평균

![approximation-algorithm](https://user-images.githubusercontent.com/72328687/210140739-8aa065e9-463f-4069-86dd-1c9dc91ee278.png)

### 윈도우

**윈도우: 유한 또는 무한 데이터 소스를 가져와 처리를 위해 시간 경계를 따라 유한한 크기의 조각으로 자르는 개념**

![windows](https://user-images.githubusercontent.com/72328687/210140740-6f27aa60-4563-483e-bd00-142e78bf1564.png)

- **고정 윈도우(Fixed window) = 텀블링 윈도우(tumbling window)**
  - 고정된 크기로 시간을 분할하는 윈도우를 설정
  - 이 윈도우는 서로 겹치지 않음!
- **슬라이딩 윈도우(sliding window) = 호핑 윈도우(hopping window)**
  - 고정 윈도우와 같이 고정된 길이로 분할
  - 윈도우가 서로 겹칠 수 있으며 주기가 길이와 같아지면 고정윈도우가 됨
- **세션(session)**
  - 말 그대로 세션을 활용해 윈도우를 분할
  - 사용자의 행동을 분석하기에 용이

## 처리 시간 윈도우

처리시간으로 윈도우를 구성할 때 시스템은 어느 정도의 처리 시간이 지날 때까지 들어오는 데이터를 버퍼링한다

e.g. 5분 길이의 고정 윈도우의 경우 5분 동안의 입력 데이터를 버퍼링하여 이 데이터를 묶어서 다음 처리를 위해 보냄

- **처리 시간 윈도우의 장점**
  - 단순하다. 시간을 기준으로 데이터를 셔플링할 필요가 없어 구현이 극도로 간단함
  - 윈도우가 완료되는 시점을 판단하기 쉬움.
    - 윈도우의 완료 시점을 완벽하게 결정하기 때문에 지연된 데이터를 다룰 필요가 없음을 의미
        (지연된 데이터를 무시하는 격으로 걸로 보이긴 하지만..)
  - 운영 중단 감지 등 모니터링을 위한 시스템 등 데이터 소스가 관측되는 시점을 기준으로 정보를 추론하고자 하는 경우 적합
- 단점
  - 이벤트가 발생한 순서를 제대로 보장해야 한다면 처리 시간 윈도우는 적합하지 않다.
    - 오늘날의 여러 분산된 입력 소스를 고려했을 때(네트워크 환경 등) 아쉽게도 이벤트 시간 순서대로 데이터가 들어올 확률은 드물다
    - 이럴 때 필요한 것이 이벤트 시간 윈도우

## 이벤트 시간 윈도우

**이벤트 시간 윈도우**는 실제 이벤트가 발생한 시간을 반영해 유한한 크기의 조각으로 데이터 소스를 관찰하고자 할 때 사용한다

2016년 이전에는 대부분의 데이터 처리 시스템에서 이에 대한 지원이 부족했으나 현재는 플링크, 스파크, 스톰, 에이펙스 등 여러 시스템이 기본적으로 이벤트 시간 윈도우를 지원하고 있다

아래는 실제 무한 데이터를 한 시간 단위의 고정 윈도우로 처리하는 예시이다.
검정색 화살표는 원래 속해야 하는 이벤트 시간 윈도우와 다른 처리 시간 윈도우에 도착한 데이터를 나타낸다.

![event-time-window](https://user-images.githubusercontent.com/72328687/210140741-e7f91631-f56e-45c1-a23e-8b2974e0a4d3.png)

여기서 알 수 있는 건 확실히 이벤트 시간이 중요한 경우에 처리 시간 윈도우로 데이터를 처리했다면 계산 결과가 부정확했을 것이라는 점이다.
**따라서 이벤트 시간에 대한 정확성 제공은 이벤트 시간 윈도우를 사용했을 때의 장점이다.**

다음은 이벤트 시간 기준 세션 윈도우를 나타낸다.
이벤트 시간 윈도우는 세션 같은 동적인 크기를 갖는 윈도우를 만들 수 있어, 고정 윈도우에 걸쳐 있는 세션을 임의로 분할해야 하는 상황을 피할 수 있다.

![event-time-session-window](https://user-images.githubusercontent.com/72328687/210140742-07671f6d-0b01-419a-9bec-c359bd1496dc.png)

물론 이러한 강력한 정확성을 보장하는 대신 다음과 같은 단점이 존재한다.

- 버퍼링(buffering)
  - 윈도우의 수명이 길어짐에 따라 데이터를 버퍼링할 필요성이 생긴다
  - 이는 영구적인 스토리지(persistent storage)를 사용하게 되는데 대부분의 데이터 처리 시스템이 의존하는 소스 유형(주로 CPU, 네트워크 대역폭이나 RAM)중에서 가장 저렴한 편이다.
- 완결성(completeness)
  - 이벤트 시간 윈도우는 주어진 윈도우에 대한 모든 데이터를 언제 다 볼 수 있는지 미리 알 수 없다.
  - 이는 언제 해당 윈도우에 대한 결과가 구체화(meterialize)될 지 모르는 것을 의미한다.
  - 데이터 처리 시스템은 이에 대해서 윈도우 완료를 결정하는 비교적 정확한 휴리스틱을 제공할 수 있다
    - **휴리스틱** : 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법
  - **밀휠, 클라우드 데이터플로우, 플링크 등에서는 워터마크를 통해 이를 제공한다**
  - 하지만 결제처럼 정확한 완결성이 필수적인 경우, 사용 가능한 유일한 방법은 파이프라인 생성자가 윈도우 결과를 언제 구체화할지, 그 결과가 시간에 따라 어떻게 정제될 지 표현할 수 있는 방법을 제공하는 것 뿐..

## 요약

- **용어 정리**
  - 데이터셋과 관련된 두 가지 차원에서의 분리
    - **기수(cardinality)**: 유한/무한 데이터
    - **구성(constitution)**: 테이블/스트림
- **잘 설계된 배치 및 스트리밍 시스템의 상대적인 평가**
  - 배치는 사실상 스트리밍의 엄격한 부분 집합
- **이벤트 시간과 처리 시간의 중요한 차이**
  - 두 시간의 차이점
  - 어떤 시간을 기준으로 하냐에 따라 데이터를 분석할 때 만날 수 있는 어려움들에 대한 이야기
  - 완결성이라는 개념을 떠나 시간에 따라 변하는 데이터를 수용할 수 있는 방향으로 전환할 필요가 있음
- **현재 무한/유한 데이터 처리에 배치/스트리밍 엔진을 통틀어 공통으로 쓰이는 데이터 처리 패턴**
  - 시간 무시
  - 근사
  - 처리 시간 윈도우
  - 이벤트 시간 윈도우
