# 02. 데이터 처리의 무엇을, 어디서, 언제, 어떻게

## 2장에서는 무엇을 알아볼 것인가?

2장에서는 아래와 같이 데이터 처리 패턴에 대해 좀 더 자세히 구체적인 예를 살펴본다.

- 어떤 목적을 가지고 무슨 결과를 계산해야하고 (데이터를 사용할 용도)
- 어디에서 결과가 계산되어야 하고 (파이프라인에서의 윈도우의 사용 등)
- 언제 결과가 구체화 되어야 하고 (어느 시점으로 이 데이터가 모두 입력되었다고 판단할지?)
- 계산된 결과 사이의 관계가 어떻게 되는가? (데이터를 계속 축적할 것인지? 아니면 독립적인지?)

2장을 마무리 지을때쯤, 강력한 비순서 데이터 처리를 위해 필요한 원칙과 개념 중 우리가 중요하다고 여기는 것들을 이해할 수 있을 것이다

아파치 빔은 배치 및 스트리밍 데이터 처리를 위한 통합 프로그래밍 모델이다.

그리고 다양한 언어에 대한 SDK를 제공하며, 아파치 플링크, 스파크, 클라우드 데이터플로우 등의 실행 엔진에서 이식성을 유지하며 실행 가능하다

아파치 빔은 이 책에서 다루는 개념을 거의 완벽하게 표현할 수 있는 방법이다
최근에는 아파치 빔이 아니라 다른 시스템들도 이 책에서 다루는 것과 비슷한 모델을 이미 지원하는 경우가 많다.
그러나 본질적인 것은 자주 바뀌지 않으니 아파치 빔이라는 창을 통해 바라본 개념이라 해도 이 개념들이 앞으로 우리가 만날 대부분의 시스템에도 적용할 수 있을 것임을 기억하자.

## 용어 정리

- **트리거(trigger)**
  - 어떤 외부 신호로 윈도우가 출력되는 시점을 선언하는 방법
  - e.g. 카메라 사진 촬영 버튼 클릭 시 사진이 출력됨
- **워터마크(watermark)**
  - 이벤트 시간을 기준으로 입력이 완료되었음을 표시하는 방법
  - 2장에서는 워터마크 기본만 다루고 3장에서 깊이 있게 다룰 예정
- **누적(accumulation)**
  - 같은 윈도우 내에서 관찰되는 여러 결과 사이의 관계를 명시

## 이 챕터에서는 아래 4가지 질문을 통해 개념을 이해해보자

1. `무슨` 결과가 계산되어야 하는가?
    1. 이 질문은 파이프인에서 쓰는 **변형(transformation)의 종류**로 답할 수 있다
    2. e.g. 합을 계산, 히스토그램 만들기, 기계학습 모델 훈련
2. 이벤트 시간의 `어디`에서 결과가 계산되어야 하는가?
    1. 파이프라인에서 **이벤트 시간 윈도우의 사용**으로 결정된다
    2. 이벤트 시간 윈도우가 아닌 다른 윈도우 형태도 여기에서 답할 수 있는 내용에 포함된다
3. 처리 시간의 결과가 `언제` 구체화되는가?
    1. 이 질문은 **트리거와 워터마크**로 답이 주어진다
    2. 트리거로 인해 이 데이터는 이미 구체화 되었다를 표현할 수도 있고, 이에 대한 표시로 워터마크를 생성할 수도 있다.
4. 결과 사이의 관계가 `어떻게` 되는가?
    1. 이 질문은 사용되는 **데이터 누적(accumulation)의 형태**로 답이 주어진다
    2. 누적의 형태로는
        1. 모든 결과가 독립적이며 구분되는 무시 모드(discarding mode)
        2. 이후 결과가 이전 결과 위에 놓이는 **누적 모드(accumulating mode)**
        3. 누적 값과 이전에 트리거된 값에 대한 철회가 함께 출력되는 **누적 및 철회 모드(accumulating and retracting mode)**

## 배치 처리의 기본: 무엇과 어디서

아파치 빔 자바 SDK 의사코드(pesudo code)와 함께 여러 윈도우 기반의 데이터파이프 사례들을 살펴봅니다.

### 먼저, 여러 의사코드(pseudo code)가 나오는데 이에 대한 용어 정의

PCollections

- 데이터셋을 표현. 이 데이터셋에는 병렬 변환 적용이 가능하다 (P는 병렬(parallel)을 의미)

PTransforms

- PCollections에 적용돼 PCollections를 생성하는 연산
- 요소 단위 변환, 여러 요소를 집계(aggregation)/그룹핑 하거나, 다른 PTransforms의 조합된 형태일 수도 있다.

![1](https://user-images.githubusercontent.com/72328687/213257186-0f10d2ef-7961-44d7-abf9-af154fc20543.png)

### 무엇: 변환

고전적인 배치 처리에 적용되는 변환은 `무슨 결과가 계산되는가?`에 대한 답을 결정한다
이미 고전 배치 처리에 익숙하더라도 이 개념 기반으로 다른 개념들이 성장했기에 이것부터 살펴보자

### 처리시간 윈도우 + 고전적인 배치

아래와 같이 시간에 따라 데이터가 쌓이고 이 데이터의 합을 출력하는 배치 작업이라면
처리시간(processing time)기반으로 데이터의 합을 구하기에 각 처리시간 시점에 따라 값이 달라진다.

즉 처리시간의 시점을 나타내는 가로 선을 기반으로 데이터가 나눠지는 것을 볼 수 있다.

의사 코드와 함께 그래프를 살펴보자

```java
// 합계 파이프라인
PCollection<String> raw = IO.read(...);
PCollection<KV<Team, Integer>> input = raw.apply(new ParseFn());
PCollection<KV<Team, Integer>> totals = input.apply(Sum.integersPerKey());
```

![2](https://user-images.githubusercontent.com/72328687/213257184-eb21667a-8c31-4678-971d-bb77db0bcd20.png)

![3](https://user-images.githubusercontent.com/72328687/213257181-76b83cd7-4f9a-446f-8ce0-5231b1f13633.png)

### 어디서: 윈도우

윈도우는 데이터 소스를 시간 경계를 따라 자르는 작업이고 이벤트 시간 윈도우를 적용하고 배치를 스트리밍으로 변경했을 때 데이터파이프 처리 그래프를 살펴보자

아래 그래프를 보면 세로 축이 새로 생긴 것을 볼 수 있는데 이는 2분 단위의 이벤트 시간 윈도우를 적용했기 때문이다

```java
// 윈도우 합 코드
PCollection<KV<Team, Integer>> totals = input
 .apply(Window.into(FixedWindows.of(TWO_MINUTES))) // 2분 주기 고정 윈도우 사용
 .apply(Sum.integersPerKey()));
```

![4](https://user-images.githubusercontent.com/72328687/213257177-09719e2f-c489-416f-be68-a6a146c898dd.png)

![5](https://user-images.githubusercontent.com/72328687/213257176-d4803026-3bfd-46d2-9969-e37a46efff69.png)

## 스트리밍으로 전환: 언제와 어떻게

위에서 배치 시스템에서 윈도우 파이프라인이 실행되는 모습을 살펴봤고

이제 스트리밍으로 전환해 우리가 원하는 이상적인 모습. 즉, 결과가 출력될 때까지 지연은 짧되 무한 데이터 입력을 다룰 수 있는 방법을 살펴보자

### 언제: 트리거가 좋은 이유는 트리거가 좋기 때문이다

트리거는 `처리 시간의 결과가 언제 구체화되는가?` 라는 질문에 답을 준다.

트리거는 처리 시간에서 언제 윈도우의 결과가 생성돼야하는지를 선언해준다.
트리거 자체는 결과 출력 시점 결정을 이벤트 시간에서의 워터마크 처리 같은 다른 시간 영역에서 일어나는 일에 기반해 결과를 내릴 수도 있다.
말이 조금 어려운데 이벤트 시간 영역 기반 처리를 위해 워터마크를 사용할 수 있다는 말이다.

윈도우별로 생성되는 각 출력을 윈도우의 `패널`(pane)이라고 부른다.

트리거에는 다음 두 가지 경우가 있는데 하나만 사용하거나 두 가지를 조합해서 사용하는 경우가 대부분이다.

- 반복 업데이트 트리거(repeated update trigger)
  - 말그대로 일정주기로 반복 실행되는 트리거
  - 이 트리거는 주기적으로 윈도우를 위해 업데이트된 패널을 생성한다.
  - 반복 업데이트 트리거의 동작 주기를 통해 출력의 지연 정도와 비용 사이의 조율도 가능
- 완결성 트리거(completeness trigger)
  - 이 트리거는 윈도우 내 입력이 일정 기준 완료됐다고 믿는 시점 이후에 윈도우를 위한 패널을 생성한다.
  - 배치 처리에서 봤던 것과 유사

아래 의사 코드와 그래프를 살펴보자 각 시점마다 여러 패널이 생기는 것을 볼 수 있다

```java
// 윈도우 합 코드
PCollection<KV<Team, Integer>> totals = input
 .apply(Window.into(FixedWindows.of(TWO_MINUTES))
         .triggering(Repeatedly(AfterCount(1)))) // repeated trigger 추가
 .apply(Sum.integersPerKey()));
```

![6](https://user-images.githubusercontent.com/72328687/213257172-7130e339-f887-4689-acb6-e9052bdf1dcf.png)

![7](https://user-images.githubusercontent.com/72328687/213257170-73c050b0-90f4-4a15-a8ea-0346e81c6038.png)

위 처리방식은 어떤 특성을 가질까?

- 이 값들은 시간 경과에 따라 결국 원하는 결과에 도달한다.
- 이는 대용량 데이터를 처리하여 합을 계산하는 식의 집계 과정은 정보 손실 없이 스트림의 규모를 줄일 수 있다.
  - 특히 일정 키에 속하는 데이터 규모가 큰 경우 적합한데, 한 팀에서 선수들이 활동하고 선수들의 점수를 집계하는 경우가 있을 수 있다.
- **그러나 데이터가 너무 자주 결과가 생성된다는 단점도 있다**
  - 요구사항마다 다르겠지만 굳이 원하는 결과를 얻기 위해서 새 입력 데이터를 만들어낼 때 마다 계산을 업데이트할 필요가 없을 수 있다.
  - 이럴 때 도입 해볼 수 있는 것이 **처리 시간 지연**이다.

### 처리 시간 지연

트리거에 처리시 시간 지연을 도입하는 방법은 다음 두 가지가 있다.

- **정렬 지연(aligned delay)**
  - 키와 윈도우 전반에 걸쳐 **고정된 영역으로 처리 시간이 나뉨**
  - 스파크 스트리밍 같은 마이크로 배치 스트리밍 시스템에서 볼 수 있음
  - 지연에 대해 예측가능성이 높다.
  - 그리고 모든 업데이트가 한 번에 일어나기에 적절한 부하 처리를 위해 더 큰 최대치를 다룰 수 있도록 미리 리소스를 프로비저닝(provisioning)할 필요가 있다.
    - 이 문제에 대한 대안으로 비정렬 지연을 활용할 수 있다.
- **비정렬 지연(unaligned delay)**
  - 한 윈도우 안에서 관찰된 데이터를 기준으로 지연
  - 데이터가 관찰된 시점에서 지연이 시작되므로 정렬 지연과 달리 시스템의 부하를 고르게 분산시킨다. 이런 점에서 대규모 처리를 위해 더 좋은 선택이라고 볼 수 있다.

- 반복 업데이트 트리거는 언제 결과의 정확성이 달성되는지에 대한 기준 없이 정확한 쪽으로 수렴한다는 사실만으로 충분하고 결과가 주기적으로 업데이트 되기를 원할 때 매우 유용하다.
- 하지만 분산 시스템에서는 다양한 이유로 이벤트 시간 왜곡이 발생하므로
- 결국 결과가 입력 데이터에 대해 정확하고 온전한 관점을 언제부터 제시하기 시작하는지 추적하기 어렵다
- 입력 완결성이 중요하다면 막연한 추정보다는 완경성에 대해 추론할 수 있는 방법이 필요한데,
- 이게 바로 `워터마크`의 역할이다.

### 언제: 워터마크

워터마크는 **이벤트 시간 영역에서 입력 완결성을 표현하는 시간적 개념이다.**

그리고 `처리 시간의 결과가 언제 구체화되는가?` 라는 질문에 대한 답을 보조하는 역할을 한다.

기본적인 원리는 워터마크가 생성되면 해당 시점 이전의 이벤트 시간을 갖는 모든 입력은 이미 시스템에서 봤다고 믿는 것이다.

워터마크의 종류에 따라 이 추정이 엄격히 보장되기도하고 쓸만한 추측이 되기도 한다.

### 워터마크의 종류

- **완벽한 워터마크(perfect watermark)**
  - 입력한 데이터를 완벽하게 이해하고 있다면 완벽한 워터마크 구축이 가능
  - 이 경우 모든 데이터는 정시에 도착하고 당연히 지연 데이터는 존재하지 않음
- **휴리스틱 워터마크(heuristic watermark)**
  - 휴리스틱 워터마크는 입력에 대해 가능한 모든 정보(분할 정보, 분할 내 순서, 파일의 증가 비율 등)를 고려해 최대한 정확한 진행 상황을 추정하는 것이다. 그리고 다수의 경우에 이 추정은 제법 정확하다.
  - **현실적으로 여러 곳에서 분산돼 들어오는 입력의 경우에는 입력 데이터를 완벽히 이해하는 것은 불가능하다. 따라서 이 경우 최선의 선택은 휴리스틱 워터마크가 될 것이다.**
  - 결국 휴리스틱 워터마크를 사용한다는 것은 무언가 잘못되어 지연 데이터가 발생할 수 있음을 의미하고, 이런 지연 데이터를 어떻게 다룰 것인지 고민해야한다.

워터마크는 완결성을 결정하기 때문에 완결성 트리거의 밑바탕이 된다.

두 워터마크의 데이터 파이프 모습을 그래프로 살펴보자

- 두 워터마크 모두 윈도우의 끝을 통과할 때 윈도우가 구체화된다.
- 완벽한 워터마크는 데이터를 놓치는 경우가 없지만 휴리스틱 워터마크를 사용했을 때는 일부 데이터를 놓치는 경우를 볼 수 있다.

![8](https://user-images.githubusercontent.com/72328687/213257166-76793e21-f6f8-48d4-a830-02bee0fd7f5e.png)

![9](https://user-images.githubusercontent.com/72328687/213257156-1d7e04ab-6203-4ec9-9066-dbb1b7d1fad4.png)

만약 남용 탐지(abuse detection)처럼 최대한 빠르게 유의미한 데이터 다수를 확인해 결과를 내야하기에 지연 데이터를 무시해버리는 것이 목적인 상황이라면, 완벽한 워터마크 대신 꼭 휴리스틱 워터마크를 선택할 필요는 없다.

이런 경우 백분위 워터마크(percetile watermark)를 사용해 지연 데이터의 일부분을 계산에서 빼버릴 수도 있다. 이는 3장에서 다룬다

### 워터마크 단점

- 너무 지연될 수 있음(=느림)
  - 완결되지 않은 데이터를 기다리느라 정상적으로 지연된 경우, 결과를 내는 기준이 워터마크의 진행 정도에만 의존하고 있다면 출력에 직접적으로 지연이 발생한다.
  - 워터마크가 완결성에 대한 매우 유용한 개념을 제공한느 것은 맞지만, 결과 생성을 위해 완결성에 의존하는 것이 항상 이상적이지는 않다.
  - 시간이나 하루 단위 유용한 정보를 보여주는 대시보드의 경우, 윈도우의 결과를 보기 위해 1시간이나 하루를 기다리는 것보다는 입력이 진행되면서 점차 다듬어진 결과가 보이고 마지막에는 완벽해지는 것이 더 나을 수 있다.
- 너무 성급하게 결과를 출력할 수 있음
  - 워터마크 이전의 이벤트 시간을 갖는 데이터가 뒤늦게 관측될 수 있음.

- 완경성은 무한 데이터 스트림의 비순서 처리를 요하는 대부분의 경우 충분하지 않다.
- 위에서 살펴본 워터마크의 두 단점이 그 근거이다.
- 완결성에만 의존하는 시스템에서는 낮은 지연과 정확성을 동시에 갖추는 것은 불가능하다
- 그럼에도 이런 상황에 최선을 취하는 방법은 무엇일까?
  - 반복 업데이트 트리거가 낮은 지연을 보이지만 완결성에 대한 지원이 결필되어있고
  - 워터마크가 완결성을 지원하지만 지연 문제가 발생할 수 있다
  - 그리고 이 둘을 조합한다면?!

### 언제: 조기/정시/지연 트리거

반복 업데이트 트리거, 완결성/워터마크 트리거를 살펴봤으나 많은 경우 둘 중 하나만으로 충분한 결과를 가져오지 못한다. 그러나 이 둘을 결합한다면? 이야기가 달라진다.

아파치 빔은 이런 사실을 인지해 워터마크 트리거의 앞뒤로 반복 업데이트 트리거를 도입할 수 있도록 표준 워터마크 트리거를 확장해두고 있다.

복합된 트리거에 의해 구체화되는 패널은 조기/정시/지연 이고 그래서 `조기/정시/지연 트리거`(early/on-time/late trigger)라고 부른다

조기/정시/지연 트리거는 반복 업데이트 트리거를 이용해 완벽한 워터마크와 휴리스틱 워터마크 사이의 결과 차이를 줄인다.

그러나 완벽한 트리거와 달리 해당 윈도우에 데이터가 남아 있지 않음을 뜻하는 윈도우의 수명을 어느정도로 할지 결정해야하는데, 이와 관련해서 허용된 지연 범위에 대한 이야기를 해보자

- **생략 가능한 조기 패널**
  - **워터마크가 윈도우 끝을 지나기 전**에 주기적으로 작동하는 반복 업데이트 트리거의 결과물.
  - 이 트리거로 생성되는 패널은 예측 결과를 담고 있고. 반복 업데이트 되므로 시간에 따라 윈도우가 변하게된다.
  - 이는 워터마크가 너무 느려질 수 있는 단점을 보완한다.
- **단일 정시 패널**
  - **완결성/워터마크 트리거가 윈도우 끝을 통과한 후**에 동작하는 트리거의 결과물
  - 이 트리거로 인해서 시스템은 윈도우의 입력이 완료되었다고 믿을 수 있고 누락된 데이터에 대한 판단이 가능하기에 중요하다.
  - 그리고 위 이유로 완결성이 보장되면 외부 조인을 수행할 때 부분 조인을 출력하거나 하는 등의 행동이 가능해진다
- **생략 가능한 지연 패널**
  - **워터마크가 윈도우 끝을 통과한 후**에 주기적으로 트리거되는 반복 업데이트 트리거의 결과물
  - 이 트리거와 조기 패널에 쓰인 트리거가 동일할 필요는 없다
  - 완벽한 워터마크의 경우 지연 패널은 의미가 없고 휴리스틱 워터마크에서 늦게 도착하는 데이터가 있는 경우를 보완해준다

이게 데이터 파이프 예시를 살펴보자

```java
// 조기, 정시, 지연 API릁 통한 트리거
PCollection<KV<Team, Integer>> totals = input
 .apply(
  Window.into(FixedWindows.of(TWO_MINUTES)) // 2분 주기 고정 윈도우
     **.**triggering(
      AfterWatermark() //워터 마크 이후에 어떻게 할 것인지
       .WithEarlyFirings(AlignedDelay(ONE_MUNUTE)) // 1분 지연 조기 반복 트리거
       .WithLaterFirings(AfterCount(1)) // 지연 트리거 1번
     )
 ) 
 .apply(Sum.integersPerKey()));
```

![10](https://user-images.githubusercontent.com/72328687/213257151-79902709-ee18-4382-b8ef-0c60845779f5.png)

![11](https://user-images.githubusercontent.com/72328687/213257139-9c067c73-b098-4c1b-8c28-5143b6ec7025.png)


- 가장 눈에 띄는 점은 완벽한 워터마크와 휴리스틱 워터마크에서 데이터 결과 차이가 좁혀진다는 점이다.
  - 추가로 워터마크 트리거를 사용하기 때문에 완결성에 대한 판단을 내릴 수 있고 데이터 누락을 고려할 필요가 있는 외부 조인, 이상 감지 등의 상황 역시 잘 다룰 수 있다
- 그리고 중요한 차이점은 바로 윈도우의 수명이다
  - 휴리스틱 워터마크의 경우 지연 데이터가 있을 수 있기에 이에 대한 상태 정보를 가지고 있어야한다.
  - 이게 바로 윈도우의 수명이다.
  - 윈도우의 수명에 대해서는 허용된 지연 범위(allowed lateness)와 가비지 컬렉션과 함께 알아보자.

### 언제: 허용된 지연 범위(가비지 컬렉션)

비순서 스트리밍 시스템과 관련해 현실적으로 필요한 내용인 가비지 컬렉션을 다뤄보자.

무한 데이터를 다루고 있다면 결국 메타데이터를 포함한 윈도우 상태를 영구적으로 포존해야 하는 비현실적인 상황이 되고 결국에는 디스크 공간이 부족해지는 상황이 될 것이다.

결국 현실적으로 비순서 처리 시스템은 윈도우 수명을 제한할 방법이 필요하다.
이를 해결하는 명쾌하고 간결한 방법은 시스템 내에 허용된 지연 범위를 정의해주는 것이다.

즉 데이터의 특성을 잘 파악하여 적절한 지연 범위를 결정하는 것이 중요할 것이다.

### 어떻게: 누적

이제 마지막 질문인 `결과 사이의 관계가 어떻게 되는가?` 에 대한 답을 알아보자.

하나의 윈도우에 대해 트리거가 여러 패널의 결과를 생성하는 경우에는 위 질문에 대해서 필수적으로 답변해야할 것이다.

사실상 데이터는 누적되는 것이고 **3가지 다른 종류의 누적 모드(accumulation mode)**에 대해서 알아보자

- **무시(discarding)**
  - 패널이 구체화될 때마다 이전에 저장된 값을 더하거나 하지 않고 무시한다.
  - 패널별로 독립적인 값을 담고 있고
  - 데이터를 받아 처리하는 시스템이 누적 작업을 스스로 하고자 할 때 유용하다
- **누적(accumulating)**
  - 패널이 구체화 될 때마다 이전에 저장된 상태가 보존되고 기존 상태와 함께 새로운 값을 결정한다.
  - 이는 각가의 패널이 갖는 값이 이전 패널 값을 바탕으로 형성됨을 의미하고
  - 이전 결과를 간단히 덮어쓰는 형태일 때 유용하다.
  - Hbase나 Bigtable 같은 키/값 저장소에 결과를 출력하는 경우가 이에 해당한다
- **누적 및 철회(accumulting and retacting)**
  - 누적 모드와 유사하지만 새 패널을 생성할 때 이전 패널과 독립적인 철회 정보도 함께 생성한다.
  - 이 철회 정보는 어떤 데이터가 만료되었고 이 데이터를 어떻게 갱신할 것인지에 대한 정보이다.
    e.g. 이전에 결과가 X라고 했지만 이는 틀렸고, 마지막에 말한 X를 제거하고 Y로 교체하라
  - 다음과 같은 상황에서 유용하다.
    - 현재 시스템에서 생성된 데이터를 소비한 이후 시스템이 결과를 다른 기준으로 다시 그룹핑하고자 할 때. 즉, 새로 생성된 값이 이전 값과 다른 키로 묶여 다른 그룹에 속할 수도 있는데 이 경우 새 값이 단순하게 이전 값을 덮어쓸 수는 없고 대신 이전 값을 지우기 위한 명확한 정보가 필요한 상황
    - 세선 윈도우에서도 이 방식이 유용한데 이는 8장에서 자세히 살펴본다.

## 요약

- **트리거**
  - 적용 목적에 적절하도록 출력을 구체화하는 정확한 시점을 명시하는 선언 방법
  - 단순히 이 시점에 결과를 구체화해줘! 라는 명령
    - e.g 카메라 촬영 버튼
  - 트리거는 완결성을 보장할 수 없음 단순히 이 시점에 완결됐다고 판단할 게를 결정하는 정도. 그래서 워터마크와 같은 완결성을 보장하는 무언가와 조합해야함
- **워터마크**
  - 무한 비순서 데이터 처리에서 완결성과 누락 데이터에 대한 결정을 내릴 수 있게 해주는 이벤트 시간 내에서의 진행 정도를 표현하는 강력한 개념
  - 단순히 특정 시점에 대한 완결성, 누락 데이터에 대한 상태를 표시하는 방법
    - e.g 완벽한 워터마크, 휴리스틱 워터마크
  - 워터마크는 완결성을 지원하지만 데이터가 너무 성급하거나 너무 느리게 완결됐다고 판단할 수 있다.
    - 이를 보완하기 위해 트리거와 조합해서 사용한다
  - 현실 세계에서 사실상 비순서 무한 데이터에 완벽한 워터마크를 사용하기는 어렵고 휴리스틱 워터마크를 적절히 사용하게 된다.
    - 이 때 조기/정시/지연 트리거를 조합해서 사용함
- **누적**
  - 시간에 따라 여러 번 구체화가 발생할 때 한 윈도우에서 나온 여러 결과 사이의 관계를 의미한다.
- **2장에서 만나본 4가지 질문**
    1. `무슨` 결과가 계산되어야 하는가?
        1. 데이터 변환
    2. 이벤트 시간의 `어디`에서 결과가 계산되어야 하는가?
        1. 윈도우의 결정
    3. 처리 시간의 결과가 `언제` 구체화되는가?
        1. 트리거와 워터마크를 이용한 완결성, 지연 개선
    4. 결과 사이의 관계가 `어떻게` 되는가?
        1. 누적
