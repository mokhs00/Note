# 개요

- [가상 면접 사례로 배우는 대규모 시스템 설계 기초](http://www.yes24.com/Product/Goods/102819435)책을 읽고 내용을 상기 하기위해 정리 및 기록합니다.

- [개요](#개요)
  - [사용자 수에 따른 규모 확장성](#사용자-수에-따른-규모-확장성)
    - [데이터베이스](#데이터베이스)
      - [어떤 데이터 베이스를 사용할 것인가?](#어떤-데이터-베이스를-사용할-것인가)
    - [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
    - [로드밸런서](#로드밸런서)
    - [데이터베이스 다중화](#데이터베이스-다중화)
    - [캐시](#캐시)
      - [캐시 계층](#캐시-계층)
      - [캐시 사용 시 유의할 점](#캐시-사용-시-유의할-점)

## 사용자 수에 따른 규모 확장성

- 수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, **지속적인 계량과 끝없는 개선이 요구되는 여정**이다.
- 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계하는 방법에 대해 알아보자.

### 데이터베이스

- 사용자가 늘면 서버 하나로는 충분하지 않아 여러 서버를 두어야한다.
- 하나는 웹/모바일 트래픽 처리 서버(웹 계층), 데이터베이스 서버(데이터 계층)이다.
- 이 계층을 분리하면 각각 독립적으로 확장해 나갈 수 있다.

#### 어떤 데이터 베이스를 사용할 것인가?

- 기본적으로 과거 오래전부터 쓰인 관계형 데이터베이스(Realational database)와 비-관계형 데이터베이스 사이에서 고를 수 있다.
- 이 두 데이터베이스는 다음과 같은 차이가 있다.
  - `관계형 데이터베이스`(RDBMS)
    - 관계형 데이터베이스 관리 시스템(RDBMS: Relation Data-base Management System)라고도 부른다.
    - 대표적인 것으로 MySQL, 오라클, PostgreSQL 등이 존재
    - 자료를 테이블과 열, 칼럼으로 표현하며 SQL을 사용하면 여러 테이블에 있는 데이터를 **그 관계에 따라 조인(Join)**하여 합칠 수 있다.
  - `비 관계형 데이터베이스`(NoSQL)
    - NoSQL이라고도 부른다.
    - 대표적인 것으로 AWS DynamoDB, HBase, Cassandra, Neo4j, CouchDB, MongoDB, Redis 등이 있다.
    - NoSQL은 다음과 같은 네 부류로 나눌 수 있다.
      - `키-캆 저장소(key-value store)`
      - `그래프 저장소(graph store)`
      - `칼럼 저장소(column store)`
      - `문서 저장소(document store)`
    - 비-관계형 데이터베이스는 일반적으로 조인 연산을 지원하지 않는다.
- 대부분의 개발자에게는 RDBMS가 40년 이상 살아남아 잘 사용된 검증된 시스템이라는 점에서 사용하기에 최선일 것이다.
- **하지만 시스템에 따라서 비-관계형 데이터베이스가 더 적합할 수 있다. 이 경우는 다음과 같다**
  - 아주 낮은 응답 지연시간(latency)이 요구됨
  - 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
  - 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
  - 아주 많은 양의 데이터를 저장할 필요가 있음

### 수직적 규모 확장 vs 수평적 규모 확장

- `수직적 규모 확장`(vertical scaling)
  - 스케일 업(scale up)이라고도 함
  - 서버에 고사양 자원(CPU, RAM 등)을 추가하여 성능을 개선하는 행위
- `수평정 규모 확장`
  - 스케일 아웃(scale out)이라고도 함
  - 더 많은 서버를 추가하여 성능을 개선하는 행위
- 서버에 유입되는 트래픽의 양이 적을 때는 스케일 업이 가장 단순하기에 좋은 선택일 수 있다. 하지만 이는 다음과 같은 한계점, 단점을 가진다
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다
  - 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다. 즉 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다 => 굉장히 치명적
- 스케일 업은 위와 같은 단점을 가지기에 대규모 애플리케이션을 지원하는 데는 보통 스케일 아웃 방식이 적절하고 이를 위해 로드밸런서를 이용한다

### 로드밸런서

- 로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.
- 스케일 아웃 방식을 확장할 때 사용하며 부하 분산 집합에 또 하나의 웹 서버를 추가하면 장애를 자동복구하지 못하는 no failover 문제를 해소하며 웹 계층의 가용성(availability)을 향상시킨다.
- 로드밸런서 + health check를 이용해 서버 장애 상태에 따라 오토스케일링 등을 통해 유연한 확장 및 장애 복구를 할 수도 있다.

### 데이터베이스 다중화

- 많은 데이터베이스 관리 시스템은 다중화를 지원하며 보통 서버 사이에 주(master)-부(slave)관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다. (slave를 read replica라고도 표현한다)
- 쓰기 연산(write operation)은 master에서만 지원하며 slave는 master로 부터 해당 데이터 사본을 전달받으며, 읽기 연산(read operation)만을 지원한다.
- 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높아 slave 수가 master보다 많다.
- 데이터베이스를 다중화 하게 되면 다음과 같은 이점이 있다
  - `처리 성능 향상`: 읽기 연산은 slave 데이터베이스들로 분산되므로 병렬로 처리될 수 있는 질의(query)의 수가 늘어나 전체적인 처리 성능이 좋아진다.
  - `안정성(reliability)`: 데이터를 지역적으로 떨어진 여러 장소에 다중화 시켜두면 자연 재해 등으로 데이터베이스 서버 일부가 파괴되어도 데이터는 보존된다. 
  - `가용성(availability)`: 데이터를 여러 지역에 복제해 둠으로써 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스를 할 수 있게 된다.
- 이와 관련해서 특정 데이터베이스가 다운되는 경우 다음과 같은 상황들이 있을 것이다.
  - slave가 하나인 상태에서 해당 slave가 다운된 경우, 읽기 연산은 한시적으로 모두 master 데이터베이스로 전달된다. slave가 여러 개인 상황에서는 장애가 발생하지 않은 다른 slave로 읽기 연산이 전달된다.
  - master가 다운된 경우, slave 중 하나가 master가 되며 새로운 slave가 하나 추가된다.
  - 운영 환경에서는 더 복잡한 일들이 벌어지는데, master에 저장된 데이터가 최신 상태가 아닐 수 있고 이를 위해 없는 데이터를 복구 스크립트(recovery script)를 돌려 추가하거나 다중 마스터(multi-masters)나 원형 다중화(circular replication) 방식을 도입하면 이런 상황에 대처하는 데 도움이 될 수도 있다. 하지만 해당 구성은 훨씬 복잡하며 실제 운영에서는 각 상황에 맞게 트레이드오프를 고려해야만 한다.

### 캐시

- 캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소로 사용된다.
- 애플리케이션의 성넝은 데이터베이스를 얼마나 자주 호출하느냐에 크게 영향을 받는데, 캐시는 이 문제를 완화할 수 있다.

#### 캐시 계층

- 캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 데이터베이스보다 훨씬 빠르다.
- 따라서 별도의 캐시 계층을 두면 성능이 개선될 뿐만 아니라 데이터베이스의 부하를 줄일 수 있고, 캐시 계층의 규모를 독립적으로 확장시키는 것도 가능하다.
- 캐싱에는 다양한 전략들이 존재하며, 캐시할 데이터의 종류, 크기, 데이터 접근 패턴에 맞는 각 캐시 전략을 잘 조합하여 선택해야한다
- 예시로 다음과 같은 전략들이 존재한다.
  - `Look-Aside 읽기 전략(=Lazy Loading)`
    - 캐시에 데이터가 없으면 DB에서 데이터를 조회하고 이를 캐시에도 추가한다.
    - 찾는 데이터가 없을 때 DB에서 직접 조회해서 입력하기 때문에 Lazy Loading이라고 한다.
    - 데이터가 없을 시 connection을 3번(cache hit, rds read, cache write)해야한다
    - 대부분의 상황에서 사용되며 굉장히 쉽다
  - `Read-Through 읽기 전략`
    - 데이터를 읽을 때 캐시로만 데이터를 읽어오고 Cache Miss가 발생하면 DB에서 해당 데이터를 캐시에 바로 저장한다.
    - Look-Aside는 Cache Miss가 발생하면 앱이 직접 DB에 데이터를 조회하는 반면, Read-Through은 앱이 아닌 캐시에서 DB에 데이터를 직접 조회하여 로드한다.
    - 동일한 데이터가 여러번 읽기 요청 되는 경우에 적합하다
  - `Write-Through 쓰기 전략`
    - 캐시에서만 데이터를 조회하고 DB에서 update, create가 발생했을 때 해당 데이터를 cache에 저장한다.
    - RDS에 데이터 추가 → cache sync 과정에서 sync 이전에 데이터를 조회하는 경우가 있을 수 있다 (=데이터 유실) 그래서 보통 Lazy Loading 전략과 결합하여 사용한다.
    - 많은 데이터를 저장해 일부 데이터가 읽히지 않는 경우 리소스 손실이 발생한다. 따라서 캐시 무표화를 위해 캐시 만료 시간인 TTL(Time To Leave)를 설정해주는 것이 좋다
    - Raed-Through 읽기 전략과 함께 사용하면 Read-Through의 모든 이점을 얻을 수 있고 데이터 일관성도 보장되어 캐시 무효화를 사용하지 않아도 된다.

#### 캐시 사용 시 유의할 점

캐시 사용 시에는 다음 사항들을 고려해야 한다.

- **캐시는 어떤 상황에서 바람직한가?**
  - 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼만하다.
- **어떤 데이터를 캐시에 두어야하는가?**
  - 휘발성 메모리에 캐시를 두므로 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- **캐시에 보관된 데이터는 어떻게 만료(expire)되는가?**
  - 이에 대한 정책을 마련해두는 것은 중요하다.
  - 만료 정책이 없으면 데이터는 캐시에 계속 남게되고 만료 시간을 너무 짧게 잡거나 너무 길게 잡으면 데이터베이스 연산을 너무 자주하거나 최신의 데이터가 아닐 가능성이 높다(=원본 데이터와 차이 발생)
- **일관성(consistency)은 어떻게 유지되는가?**
  - 일관성은 데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부이다.
  - 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않는 경우 이 일관성은 깨질 수 있다. 여러 지역에 걸쳐 시스템을 확장하는 경우에는 캐시와 저장소 사이의 일관성을 유지한느 것은 더더욱 어려운 문제가 된다.
- **장애에는 어떻게 대처할 것인가?**
  - 캐시 서버를 한 대만 두는 경우 해당 서버는 전체 시스템의 동작을 중단시켜 버릴 수 있는 단일 장애 지점(SPOF: Single Point Of Failure)이 되어벌리 가능성이 있다. 따라서 캐시 서버도 여러 지역에 걸쳐 분산시켜야한다.
- **캐시 메모리는 얼마나 크게 잡을 것인가?**
  - 캐시 메모리가 너무 작으면 데이터 접근 패턴에 따라 데이터가 너무 자주 캐시에서 밀려나버려(eviction) 캐시의 성능이 떨어진다.
  - 이를 막을 한 가지 방법은 캐시 메모리를 과할당(overprovision)하는 것이다. 이렇게 하면 캐시에 보관될 데이터가 갑자기 늘어났을 때 생길 문제도 방지할 수 있게 된다.
- **데이터 방출(eviction) 정책은 무엇인가?**
  - 캐시가 꽉 차버리면 추가로 캐시에 데이터를 넣어야 할 경우 기존 데이터를 내보내야(eviction) 한다.
  - 캐시 데이터 방출 정책에는 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 `LRU`(Least Recently Used)가 가장 널리 쓰이며 다른 정책으로는 `LFU`(Least Frequently Used - 사용 빈도가 가장 낮은 데이터를 내보냄), `FIFO`(First In First Out - 선입선출)등이 있으며 경우게 맞게 적용 가능하다.
