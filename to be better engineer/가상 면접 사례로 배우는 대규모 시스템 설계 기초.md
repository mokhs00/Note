# 개요

- [가상 면접 사례로 배우는 대규모 시스템 설계 기초](http://www.yes24.com/Product/Goods/102819435)책을 읽고 내용을 상기 하기위해 정리 및 기록합니다.

- [개요](#개요)
  - [사용자 수에 따른 규모 확장성](#사용자-수에-따른-규모-확장성)
    - [데이터베이스](#데이터베이스)
      - [어떤 데이터 베이스를 사용할 것인가?](#어떤-데이터-베이스를-사용할-것인가)
    - [수직적 규모 확장 vs 수평적 규모 확장](#수직적-규모-확장-vs-수평적-규모-확장)
    - [로드밸런서](#로드밸런서)
    - [데이터베이스 다중화](#데이터베이스-다중화)

## 사용자 수에 따른 규모 확장성

- 수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적인 과제이며, **지속적인 계량과 끝없는 개선이 요구되는 여정**이다.
- 한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로 몇백만 사용자를 지원하는 시스템을 설계하는 방법에 대해 알아보자.

### 데이터베이스

- 사용자가 늘면 서버 하나로는 충분하지 않아 여러 서버를 두어야한다.
- 하나는 웹/모바일 트래픽 처리 서버(웹 계층), 데이터베이스 서버(데이터 계층)이다.
- 이 계층을 분리하면 각각 독립적으로 확장해 나갈 수 있다.

#### 어떤 데이터 베이스를 사용할 것인가?

- 기본적으로 과거 오래전부터 쓰인 관계형 데이터베이스(Realational database)와 비-관계형 데이터베이스 사이에서 고를 수 있다.
- 이 두 데이터베이스는 다음과 같은 차이가 있다.
  - `관계형 데이터베이스`(RDBMS)
    - 관계형 데이터베이스 관리 시스템(RDBMS: Relation Data-base Management System)라고도 부른다.
    - 대표적인 것으로 MySQL, 오라클, PostgreSQL 등이 존재
    - 자료를 테이블과 열, 칼럼으로 표현하며 SQL을 사용하면 여러 테이블에 있는 데이터를 **그 관계에 따라 조인(Join)**하여 합칠 수 있다.
  - `비 관계형 데이터베이스`(NoSQL)
    - NoSQL이라고도 부른다.
    - 대표적인 것으로 AWS DynamoDB, HBase, Cassandra, Neo4j, CouchDB, MongoDB, Redis 등이 있다.
    - NoSQL은 다음과 같은 네 부류로 나눌 수 있다.
      - `키-캆 저장소(key-value store)`
      - `그래프 저장소(graph store)`
      - `칼럼 저장소(column store)`
      - `문서 저장소(document store)`
    - 비-관계형 데이터베이스는 일반적으로 조인 연산을 지원하지 않는다.
- 대부분의 개발자에게는 RDBMS가 40년 이상 살아남아 잘 사용된 검증된 시스템이라는 점에서 사용하기에 최선일 것이다.
- **하지만 시스템에 따라서 비-관계형 데이터베이스가 더 적합할 수 있다. 이 경우는 다음과 같다**
  - 아주 낮은 응답 지연시간(latency)이 요구됨
  - 다루는 데이터가 비정형(unstructured)이라 관계형 데이터가 아님
  - 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
  - 아주 많은 양의 데이터를 저장할 필요가 있음

### 수직적 규모 확장 vs 수평적 규모 확장

- `수직적 규모 확장`(vertical scaling)
  - 스케일 업(scale up)이라고도 함
  - 서버에 고사양 자원(CPU, RAM 등)을 추가하여 성능을 개선하는 행위
- `수평정 규모 확장`
  - 스케일 아웃(scale out)이라고도 함
  - 더 많은 서버를 추가하여 성능을 개선하는 행위
- 서버에 유입되는 트래픽의 양이 적을 때는 스케일 업이 가장 단순하기에 좋은 선택일 수 있다. 하지만 이는 다음과 같은 한계점, 단점을 가진다
  - 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다
  - 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않는다. 즉 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다 => 굉장히 치명적
- 스케일 업은 위와 같은 단점을 가지기에 대규모 애플리케이션을 지원하는 데는 보통 스케일 아웃 방식이 적절하고 이를 위해 로드밸런서를 이용한다

### 로드밸런서

- 로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.
- 스케일 아웃 방식을 확장할 때 사용하며 부하 분산 집합에 또 하나의 웹 서버를 추가하면 장애를 자동복구하지 못하는 no failover 문제를 해소하며 웹 계층의 가용성(availability)을 향상시킨다.
- 로드밸런서 + health check를 이용해 서버 장애 상태에 따라 오토스케일링 등을 통해 유연한 확장 및 장애 복구를 할 수도 있다.

### 데이터베이스 다중화

- 많은 데이터베이스 관리 시스템은 다중화를 지원하며 보통 서버 사이에 주(master)-부(slave)관계를 설정하고 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다. (slave를 read replica라고도 표현한다)
- 쓰기 연산(write operation)은 master에서만 지원하며 slave는 master로 부터 해당 데이터 사본을 전달받으며, 읽기 연산(read operation)만을 지원한다.
- 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높아 slave 수가 master보다 많다.
- 데이터베이스를 다중화 하게 되면 다음과 같은 이점이 있다
  - `처리 성능 향상`: 읽기 연산은 slave 데이터베이스들로 분산되므로 병렬로 처리될 수 있는 질의(query)의 수가 늘어나 전체적인 처리 성능이 좋아진다.
  - `안정성(reliability)`: 데이터를 지역적으로 떨어진 여러 장소에 다중화 시켜두면 자연 재해 등으로 데이터베이스 서버 일부가 파괴되어도 데이터는 보존된다. 
  - `가용성(availability)`: 데이터를 여러 지역에 복제해 둠으로써 하나의 데이터베이스 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스를 할 수 있게 된다.
- 이와 관련해서 특정 데이터베이스가 다운되는 경우 다음과 같은 상황들이 있을 것이다.
  - slave가 하나인 상태에서 해당 slave가 다운된 경우, 읽기 연산은 한시적으로 모두 master 데이터베이스로 전달된다. slave가 여러 개인 상황에서는 장애가 발생하지 않은 다른 slave로 읽기 연산이 전달된다.
  - master가 다운된 경우, slave 중 하나가 master가 되며 새로운 slave가 하나 추가된다.
  - 운영 환경에서는 더 복잡한 일들이 벌어지는데, master에 저장된 데이터가 최신 상태가 아닐 수 있고 이를 위해 없는 데이터를 복구 스크립트(recovery script)를 돌려 추가하거나 다중 마스터(multi-masters)나 원형 다중화(circular replication) 방식을 도입하면 이런 상황에 대처하는 데 도움이 될 수도 있다. 하지만 해당 구성은 훨씬 복잡하며 실제 운영에서는 각 상황에 맞게 트레이드오프를 고려해야만 한다.
